"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jarallax";
exports.ids = ["vendor-chunks/jarallax"];
exports.modules = {

/***/ "(ssr)/./node_modules/jarallax/dist/jarallax.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/jarallax/dist/jarallax.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jarallax: () => (/* binding */ jarallax),\n/* harmony export */   jarallaxElement: () => (/* binding */ jarallaxElement),\n/* harmony export */   jarallaxVideo: () => (/* binding */ jarallaxVideo)\n/* harmony export */ });\n/*!\n * Jarallax v2.2.1 (https://github.com/nk-o/jarallax)\n * Copyright 2024 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/jarallax/blob/master/LICENSE)\n */\nvar defaults$1 = {\n  // Base parallax options.\n  type: 'scroll',\n  speed: 0.5,\n  containerClass: 'jarallax-container',\n  imgSrc: null,\n  imgElement: '.jarallax-img',\n  imgSize: 'cover',\n  imgPosition: '50% 50%',\n  imgRepeat: 'no-repeat',\n  keepImg: false,\n  elementInViewport: null,\n  zIndex: -100,\n  disableParallax: false,\n  // Callbacks.\n  onScroll: null,\n  onInit: null,\n  onDestroy: null,\n  onCoverImage: null,\n  // Video options.\n  videoClass: 'jarallax-video',\n  videoSrc: null,\n  videoStartTime: 0,\n  videoEndTime: 0,\n  videoVolume: 0,\n  videoLoop: true,\n  videoPlayOnlyVisible: true,\n  videoLazyLoading: true,\n  disableVideo: false,\n  // Video callbacks.\n  onVideoInsert: null,\n  onVideoWorkerInit: null\n};\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win$1;\nif (typeof window !== 'undefined') {\n  win$1 = window;\n} else if (typeof global !== 'undefined') {\n  win$1 = global;\n} else if (typeof self !== 'undefined') {\n  win$1 = self;\n} else {\n  win$1 = {};\n}\nvar global$2 = win$1;\n\n/**\n * Add styles to element.\n *\n * @param {Element} el - element.\n * @param {String|Object} styles - styles list.\n *\n * @returns {Element}\n */\nfunction css(el, styles) {\n  if (typeof styles === 'string') {\n    return global$2.getComputedStyle(el).getPropertyValue(styles);\n  }\n  Object.keys(styles).forEach(key => {\n    el.style[key] = styles[key];\n  });\n  return el;\n}\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend$1(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\n\n/**\n * Get all parents of the element.\n *\n * @param {Element} elem - DOM element.\n *\n * @returns {Array}\n */\nfunction getParents(elem) {\n  const parents = [];\n  while (elem.parentElement !== null) {\n    elem = elem.parentElement;\n    if (elem.nodeType === 1) {\n      parents.push(elem);\n    }\n  }\n  return parents;\n}\n\n/**\n * Document ready callback.\n * @param {Function} callback - callback will be fired once Document ready.\n */\nfunction ready(callback) {\n  if (document.readyState === 'complete' || document.readyState === 'interactive') {\n    // Already ready or interactive, execute callback\n    callback();\n  } else {\n    document.addEventListener('DOMContentLoaded', callback, {\n      capture: true,\n      once: true,\n      passive: true\n    });\n  }\n}\n\nconst {\n  navigator: navigator$1\n} = global$2;\nconst mobileAgent = /*#__PURE__*/ /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator$1.userAgent);\nfunction isMobile() {\n  return mobileAgent;\n}\n\nlet wndW;\nlet wndH;\nlet $deviceHelper;\n\n/**\n * The most popular mobile browsers changes height after page scroll and this generates image jumping.\n * We can fix it using this workaround with vh units.\n */\nfunction getDeviceHeight() {\n  if (!$deviceHelper && document.body) {\n    $deviceHelper = document.createElement('div');\n    $deviceHelper.style.cssText = 'position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;';\n    document.body.appendChild($deviceHelper);\n  }\n  return ($deviceHelper ? $deviceHelper.clientHeight : 0) || global$2.innerHeight || document.documentElement.clientHeight;\n}\nfunction updateWindowHeight() {\n  wndW = global$2.innerWidth || document.documentElement.clientWidth;\n  if (isMobile()) {\n    wndH = getDeviceHeight();\n  } else {\n    wndH = global$2.innerHeight || document.documentElement.clientHeight;\n  }\n}\nupdateWindowHeight();\nglobal$2.addEventListener('resize', updateWindowHeight);\nglobal$2.addEventListener('orientationchange', updateWindowHeight);\nglobal$2.addEventListener('load', updateWindowHeight);\nready(() => {\n  updateWindowHeight();\n});\nfunction getWindowSize() {\n  return {\n    width: wndW,\n    height: wndH\n  };\n}\n\n// List with all jarallax instances\n// need to render all in one scroll/resize event.\nconst jarallaxList = [];\nfunction updateParallax() {\n  if (!jarallaxList.length) {\n    return;\n  }\n  const {\n    width: wndW,\n    height: wndH\n  } = getWindowSize();\n  jarallaxList.forEach((data, k) => {\n    const {\n      instance,\n      oldData\n    } = data;\n    if (!instance.isVisible()) {\n      return;\n    }\n    const clientRect = instance.$item.getBoundingClientRect();\n    const newData = {\n      width: clientRect.width,\n      height: clientRect.height,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      wndW,\n      wndH\n    };\n    const isResized = !oldData || oldData.wndW !== newData.wndW || oldData.wndH !== newData.wndH || oldData.width !== newData.width || oldData.height !== newData.height;\n    const isScrolled = isResized || !oldData || oldData.top !== newData.top || oldData.bottom !== newData.bottom;\n    jarallaxList[k].oldData = newData;\n    if (isResized) {\n      instance.onResize();\n    }\n    if (isScrolled) {\n      instance.onScroll();\n    }\n  });\n  global$2.requestAnimationFrame(updateParallax);\n}\nconst visibilityObserver = /*#__PURE__*/new global$2.IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    entry.target.jarallax.isElementInViewport = entry.isIntersecting;\n  });\n}, {\n  // We have to start parallax calculation before the block is in view\n  // to prevent possible parallax jumping.\n  rootMargin: '50px'\n});\nfunction addObserver(instance) {\n  jarallaxList.push({\n    instance\n  });\n  if (jarallaxList.length === 1) {\n    global$2.requestAnimationFrame(updateParallax);\n  }\n  visibilityObserver.observe(instance.options.elementInViewport || instance.$item);\n}\nfunction removeObserver(instance) {\n  jarallaxList.forEach((data, key) => {\n    if (data.instance.instanceID === instance.instanceID) {\n      jarallaxList.splice(key, 1);\n    }\n  });\n  visibilityObserver.unobserve(instance.options.elementInViewport || instance.$item);\n}\n\n/* eslint-disable class-methods-use-this */\nconst {\n  navigator\n} = global$2;\nlet instanceID = 0;\n\n// Jarallax class\nclass Jarallax {\n  constructor(item, userOptions) {\n    const self = this;\n    self.instanceID = instanceID;\n    instanceID += 1;\n    self.$item = item;\n    self.defaults = {\n      ...defaults$1\n    };\n\n    // prepare data-options\n    const dataOptions = self.$item.dataset || {};\n    const pureDataOptions = {};\n    Object.keys(dataOptions).forEach(key => {\n      const lowerCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n      if (lowerCaseOption && typeof self.defaults[lowerCaseOption] !== 'undefined') {\n        pureDataOptions[lowerCaseOption] = dataOptions[key];\n      }\n    });\n    self.options = self.extend({}, self.defaults, pureDataOptions, userOptions);\n    self.pureOptions = self.extend({}, self.options);\n\n    // prepare 'true' and 'false' strings to boolean\n    Object.keys(self.options).forEach(key => {\n      if (self.options[key] === 'true') {\n        self.options[key] = true;\n      } else if (self.options[key] === 'false') {\n        self.options[key] = false;\n      }\n    });\n\n    // fix speed option [-1.0, 2.0]\n    self.options.speed = Math.min(2, Math.max(-1, parseFloat(self.options.speed)));\n\n    // prepare disableParallax callback\n    if (typeof self.options.disableParallax === 'string') {\n      self.options.disableParallax = new RegExp(self.options.disableParallax);\n    }\n    if (self.options.disableParallax instanceof RegExp) {\n      const disableParallaxRegexp = self.options.disableParallax;\n      self.options.disableParallax = () => disableParallaxRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableParallax !== 'function') {\n      // Support for `true` option value.\n      const disableParallaxDefault = self.options.disableParallax;\n      self.options.disableParallax = () => disableParallaxDefault === true;\n    }\n\n    // prepare disableVideo callback\n    if (typeof self.options.disableVideo === 'string') {\n      self.options.disableVideo = new RegExp(self.options.disableVideo);\n    }\n    if (self.options.disableVideo instanceof RegExp) {\n      const disableVideoRegexp = self.options.disableVideo;\n      self.options.disableVideo = () => disableVideoRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableVideo !== 'function') {\n      // Support for `true` option value.\n      const disableVideoDefault = self.options.disableVideo;\n      self.options.disableVideo = () => disableVideoDefault === true;\n    }\n\n    // custom element to check if parallax in viewport\n    let elementInVP = self.options.elementInViewport;\n    // get first item from array\n    if (elementInVP && typeof elementInVP === 'object' && typeof elementInVP.length !== 'undefined') {\n      [elementInVP] = elementInVP;\n    }\n    // check if dom element\n    if (!(elementInVP instanceof Element)) {\n      elementInVP = null;\n    }\n    self.options.elementInViewport = elementInVP;\n    self.image = {\n      src: self.options.imgSrc || null,\n      $container: null,\n      useImgTag: false,\n      // 1. Position fixed is needed for the most of browsers because absolute position have glitches\n      // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75\n      // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'\n      position: 'fixed'\n    };\n    if (self.initImg() && self.canInitParallax()) {\n      self.init();\n    }\n  }\n  css(el, styles) {\n    return css(el, styles);\n  }\n  extend(out, ...args) {\n    return extend$1(out, ...args);\n  }\n\n  // get window size and scroll position. Useful for extensions\n  getWindowData() {\n    const {\n      width,\n      height\n    } = getWindowSize();\n    return {\n      width,\n      height,\n      y: document.documentElement.scrollTop\n    };\n  }\n\n  // Jarallax functions\n  initImg() {\n    const self = this;\n\n    // find image element\n    let $imgElement = self.options.imgElement;\n    if ($imgElement && typeof $imgElement === 'string') {\n      $imgElement = self.$item.querySelector($imgElement);\n    }\n\n    // check if dom element\n    if (!($imgElement instanceof Element)) {\n      if (self.options.imgSrc) {\n        $imgElement = new Image();\n        $imgElement.src = self.options.imgSrc;\n      } else {\n        $imgElement = null;\n      }\n    }\n    if ($imgElement) {\n      if (self.options.keepImg) {\n        self.image.$item = $imgElement.cloneNode(true);\n      } else {\n        self.image.$item = $imgElement;\n        self.image.$itemParent = $imgElement.parentNode;\n      }\n      self.image.useImgTag = true;\n    }\n\n    // true if there is img tag\n    if (self.image.$item) {\n      return true;\n    }\n\n    // get image src\n    if (self.image.src === null) {\n      self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n      self.image.bgImage = self.css(self.$item, 'background-image');\n    }\n    return !(!self.image.bgImage || self.image.bgImage === 'none');\n  }\n  canInitParallax() {\n    return !this.options.disableParallax();\n  }\n  init() {\n    const self = this;\n    const containerStyles = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden'\n    };\n    let imageStyles = {\n      pointerEvents: 'none',\n      transformStyle: 'preserve-3d',\n      backfaceVisibility: 'hidden'\n    };\n    if (!self.options.keepImg) {\n      // save default user styles\n      const curStyle = self.$item.getAttribute('style');\n      if (curStyle) {\n        self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n      }\n      if (self.image.useImgTag) {\n        const curImgStyle = self.image.$item.getAttribute('style');\n        if (curImgStyle) {\n          self.image.$item.setAttribute('data-jarallax-original-styles', curImgStyle);\n        }\n      }\n    }\n\n    // set relative position and z-index to the parent\n    if (self.css(self.$item, 'position') === 'static') {\n      self.css(self.$item, {\n        position: 'relative'\n      });\n    }\n    if (self.css(self.$item, 'z-index') === 'auto') {\n      self.css(self.$item, {\n        zIndex: 0\n      });\n    }\n\n    // container for parallax image\n    self.image.$container = document.createElement('div');\n    self.css(self.image.$container, containerStyles);\n    self.css(self.image.$container, {\n      'z-index': self.options.zIndex\n    });\n\n    // it will remove some image overlapping\n    // overlapping occur due to an image position fixed inside absolute position element\n    // needed only when background in fixed position\n    if (this.image.position === 'fixed') {\n      self.css(self.image.$container, {\n        '-webkit-clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',\n        'clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)'\n      });\n    }\n\n    // Add container unique ID.\n    self.image.$container.setAttribute('id', `jarallax-container-${self.instanceID}`);\n\n    // Add container class.\n    if (self.options.containerClass) {\n      self.image.$container.setAttribute('class', self.options.containerClass);\n    }\n    self.$item.appendChild(self.image.$container);\n\n    // use img tag\n    if (self.image.useImgTag) {\n      imageStyles = self.extend({\n        'object-fit': self.options.imgSize,\n        'object-position': self.options.imgPosition,\n        'max-width': 'none'\n      }, containerStyles, imageStyles);\n\n      // use div with background image\n    } else {\n      self.image.$item = document.createElement('div');\n      if (self.image.src) {\n        imageStyles = self.extend({\n          'background-position': self.options.imgPosition,\n          'background-size': self.options.imgSize,\n          'background-repeat': self.options.imgRepeat,\n          'background-image': self.image.bgImage || `url(\"${self.image.src}\")`\n        }, containerStyles, imageStyles);\n      }\n    }\n    if (self.options.type === 'opacity' || self.options.type === 'scale' || self.options.type === 'scale-opacity' || self.options.speed === 1) {\n      self.image.position = 'absolute';\n    }\n\n    // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)\n    //    discussion - https://github.com/nk-o/jarallax/issues/9\n    // 2. Check if parents have overflow scroll\n    if (self.image.position === 'fixed') {\n      const $parents = getParents(self.$item).filter(el => {\n        const styles = global$2.getComputedStyle(el);\n        const parentTransform = styles['-webkit-transform'] || styles['-moz-transform'] || styles.transform;\n        const overflowRegex = /(auto|scroll)/;\n        return parentTransform && parentTransform !== 'none' || overflowRegex.test(styles.overflow + styles['overflow-y'] + styles['overflow-x']);\n      });\n      self.image.position = $parents.length ? 'absolute' : 'fixed';\n    }\n\n    // add position to parallax block\n    imageStyles.position = self.image.position;\n\n    // insert parallax image\n    self.css(self.image.$item, imageStyles);\n    self.image.$container.appendChild(self.image.$item);\n\n    // set initial position and size\n    self.onResize();\n    self.onScroll(true);\n\n    // call onInit event\n    if (self.options.onInit) {\n      self.options.onInit.call(self);\n    }\n\n    // remove default user background\n    if (self.css(self.$item, 'background-image') !== 'none') {\n      self.css(self.$item, {\n        'background-image': 'none'\n      });\n    }\n    addObserver(self);\n  }\n  destroy() {\n    const self = this;\n    removeObserver(self);\n\n    // return styles on container as before jarallax init\n    const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n    self.$item.removeAttribute('data-jarallax-original-styles');\n    // null occurs if there is no style tag before jarallax init\n    if (!originalStylesTag) {\n      self.$item.removeAttribute('style');\n    } else {\n      self.$item.setAttribute('style', originalStylesTag);\n    }\n    if (self.image.useImgTag) {\n      // return styles on img tag as before jarallax init\n      const originalStylesImgTag = self.image.$item.getAttribute('data-jarallax-original-styles');\n      self.image.$item.removeAttribute('data-jarallax-original-styles');\n      // null occurs if there is no style tag before jarallax init\n      if (!originalStylesImgTag) {\n        self.image.$item.removeAttribute('style');\n      } else {\n        self.image.$item.setAttribute('style', originalStylesTag);\n      }\n\n      // move img tag to its default position\n      if (self.image.$itemParent) {\n        self.image.$itemParent.appendChild(self.image.$item);\n      }\n    }\n\n    // remove additional dom elements\n    if (self.image.$container) {\n      self.image.$container.parentNode.removeChild(self.image.$container);\n    }\n\n    // call onDestroy event\n    if (self.options.onDestroy) {\n      self.options.onDestroy.call(self);\n    }\n\n    // delete jarallax from item\n    delete self.$item.jarallax;\n  }\n  coverImage() {\n    const self = this;\n    const {\n      height: wndH\n    } = getWindowSize();\n    const rect = self.image.$container.getBoundingClientRect();\n    const contH = rect.height;\n    const {\n      speed\n    } = self.options;\n    const isScroll = self.options.type === 'scroll' || self.options.type === 'scroll-opacity';\n    let scrollDist = 0;\n    let resultH = contH;\n    let resultMT = 0;\n\n    // scroll parallax\n    if (isScroll) {\n      // scroll distance and height for image\n      if (speed < 0) {\n        scrollDist = speed * Math.max(contH, wndH);\n        if (wndH < contH) {\n          scrollDist -= speed * (contH - wndH);\n        }\n      } else {\n        scrollDist = speed * (contH + wndH);\n      }\n\n      // size for scroll parallax\n      if (speed > 1) {\n        resultH = Math.abs(scrollDist - wndH);\n      } else if (speed < 0) {\n        resultH = scrollDist / speed + Math.abs(scrollDist);\n      } else {\n        resultH += (wndH - contH) * (1 - speed);\n      }\n      scrollDist /= 2;\n    }\n\n    // store scroll distance\n    self.parallaxScrollDistance = scrollDist;\n\n    // vertical center\n    if (isScroll) {\n      resultMT = (wndH - resultH) / 2;\n    } else {\n      resultMT = (contH - resultH) / 2;\n    }\n\n    // apply result to item\n    self.css(self.image.$item, {\n      height: `${resultH}px`,\n      marginTop: `${resultMT}px`,\n      left: self.image.position === 'fixed' ? `${rect.left}px` : '0',\n      width: `${rect.width}px`\n    });\n\n    // call onCoverImage event\n    if (self.options.onCoverImage) {\n      self.options.onCoverImage.call(self);\n    }\n\n    // return some useful data. Used in the video cover function\n    return {\n      image: {\n        height: resultH,\n        marginTop: resultMT\n      },\n      container: rect\n    };\n  }\n  isVisible() {\n    return this.isElementInViewport || false;\n  }\n  onScroll(force) {\n    const self = this;\n\n    // stop calculations if item is not in viewport\n    if (!force && !self.isVisible()) {\n      return;\n    }\n    const {\n      height: wndH\n    } = getWindowSize();\n    const rect = self.$item.getBoundingClientRect();\n    const contT = rect.top;\n    const contH = rect.height;\n    const styles = {};\n\n    // calculate parallax helping variables\n    const beforeTop = Math.max(0, contT);\n    const beforeTopEnd = Math.max(0, contH + contT);\n    const afterTop = Math.max(0, -contT);\n    const beforeBottom = Math.max(0, contT + contH - wndH);\n    const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));\n    const afterBottom = Math.max(0, -contT + wndH - contH);\n    const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH));\n\n    // calculate on how percent of section is visible\n    let visiblePercent = 1;\n    if (contH < wndH) {\n      visiblePercent = 1 - (afterTop || beforeBottom) / contH;\n    } else if (beforeTopEnd <= wndH) {\n      visiblePercent = beforeTopEnd / wndH;\n    } else if (beforeBottomEnd <= wndH) {\n      visiblePercent = beforeBottomEnd / wndH;\n    }\n\n    // opacity\n    if (self.options.type === 'opacity' || self.options.type === 'scale-opacity' || self.options.type === 'scroll-opacity') {\n      styles.transform = 'translate3d(0,0,0)';\n      styles.opacity = visiblePercent;\n    }\n\n    // scale\n    if (self.options.type === 'scale' || self.options.type === 'scale-opacity') {\n      let scale = 1;\n      if (self.options.speed < 0) {\n        scale -= self.options.speed * visiblePercent;\n      } else {\n        scale += self.options.speed * (1 - visiblePercent);\n      }\n      styles.transform = `scale(${scale}) translate3d(0,0,0)`;\n    }\n\n    // scroll\n    if (self.options.type === 'scroll' || self.options.type === 'scroll-opacity') {\n      let positionY = self.parallaxScrollDistance * fromViewportCenter;\n\n      // fix if parallax block in absolute position\n      if (self.image.position === 'absolute') {\n        positionY -= contT;\n      }\n      styles.transform = `translate3d(0,${positionY}px,0)`;\n    }\n    self.css(self.image.$item, styles);\n\n    // call onScroll event\n    if (self.options.onScroll) {\n      self.options.onScroll.call(self, {\n        section: rect,\n        beforeTop,\n        beforeTopEnd,\n        afterTop,\n        beforeBottom,\n        beforeBottomEnd,\n        afterBottom,\n        visiblePercent,\n        fromViewportCenter\n      });\n    }\n  }\n  onResize() {\n    this.coverImage();\n  }\n}\n\n// global definition\nconst jarallax$1 = function (items, options, ...args) {\n  // check for dom element\n  // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  if (typeof HTMLElement === 'object' ? items instanceof HTMLElement : items && typeof items === 'object' && items !== null && items.nodeType === 1 && typeof items.nodeName === 'string') {\n    items = [items];\n  }\n  const len = items.length;\n  let k = 0;\n  let ret;\n  for (k; k < len; k += 1) {\n    if (typeof options === 'object' || typeof options === 'undefined') {\n      if (!items[k].jarallax) {\n        items[k].jarallax = new Jarallax(items[k], options);\n      }\n    } else if (items[k].jarallax) {\n      // eslint-disable-next-line prefer-spread\n      ret = items[k].jarallax[options].apply(items[k].jarallax, args);\n    }\n    if (typeof ret !== 'undefined') {\n      return ret;\n    }\n  }\n  return items;\n};\njarallax$1.constructor = Jarallax;\n\n/*!\n * Video Worker v2.2.0 (https://github.com/nk-o/video-worker)\n * Copyright 2024 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/video-worker/blob/master/LICENSE)\n */\n\nvar defaults = {\n  autoplay: false,\n  loop: false,\n  mute: false,\n  volume: 100,\n  showControls: true,\n  accessibilityHidden: false,\n  // start / end video time in seconds\n  startTime: 0,\n  endTime: 0\n};\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\nlet ID = 0;\nclass VideoWorkerBase {\n  type = 'none';\n  constructor(url, options) {\n    const self = this;\n    self.url = url;\n    self.options_default = {\n      ...defaults\n    };\n    self.options = extend({}, self.options_default, options);\n\n    // check URL\n    self.videoID = self.constructor.parseURL(url);\n\n    // init\n    if (self.videoID) {\n      self.init();\n    }\n  }\n  isValid() {\n    return !!this.videoID;\n  }\n  init() {\n    const self = this;\n    self.ID = ID;\n    ID += 1;\n    self.playerID = `VideoWorker-${self.ID}`;\n  }\n\n  // events\n  on(name, callback) {\n    this.userEventsList = this.userEventsList || [];\n\n    // add new callback in events list\n    (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);\n  }\n  off(name, callback) {\n    if (!this.userEventsList || !this.userEventsList[name]) {\n      return;\n    }\n    if (!callback) {\n      delete this.userEventsList[name];\n    } else {\n      this.userEventsList[name].forEach((val, key) => {\n        if (val === callback) {\n          this.userEventsList[name][key] = false;\n        }\n      });\n    }\n  }\n  fire(name, ...args) {\n    if (this.userEventsList && typeof this.userEventsList[name] !== 'undefined') {\n      this.userEventsList[name].forEach(val => {\n        // call with all arguments\n        if (val) {\n          val.apply(this, args);\n        }\n      });\n    }\n  }\n\n  /**\n   * Methods used in providers.\n   */\n  /* eslint-disable */\n  static parseURL(url) {\n    return false;\n  }\n  play(start) {}\n  pause() {}\n  mute() {}\n  unmute() {}\n  setVolume(volume = false) {}\n  getVolume(callback) {}\n  getMuted(callback) {}\n  setCurrentTime(currentTime = false) {}\n  getCurrentTime(callback) {}\n  getImageURL(callback) {}\n  getVideo(callback) {}\n  /* eslint-enable */\n}\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win;\nif (typeof window !== 'undefined') {\n  win = window;\n} else if (typeof global !== 'undefined') {\n  win = global;\n} else if (typeof self !== 'undefined') {\n  win = self;\n} else {\n  win = {};\n}\nvar global$1 = win;\n\n// Deferred\n// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery\nfunction Deferred() {\n  this.doneCallbacks = [];\n  this.failCallbacks = [];\n}\nDeferred.prototype = {\n  execute(list, args) {\n    let i = list.length;\n    // eslint-disable-next-line no-param-reassign\n    args = Array.prototype.slice.call(args);\n    while (i) {\n      i -= 1;\n      list[i].apply(null, args);\n    }\n  },\n  resolve(...args) {\n    this.execute(this.doneCallbacks, args);\n  },\n  reject(...args) {\n    this.execute(this.failCallbacks, args);\n  },\n  done(callback) {\n    this.doneCallbacks.push(callback);\n  },\n  fail(callback) {\n    this.failCallbacks.push(callback);\n  }\n};\nlet YoutubeAPIadded = 0;\nlet loadingYoutubePlayer = 0;\nconst loadingYoutubeDefer = /*#__PURE__*/new Deferred();\nfunction loadAPI$1() {\n  if (YoutubeAPIadded) {\n    return;\n  }\n  YoutubeAPIadded = true;\n  const src = 'https://www.youtube.com/iframe_api';\n\n  // add script in head section\n  let tag = document.createElement('script');\n  let head = document.getElementsByTagName('head')[0];\n  tag.src = src;\n  head.appendChild(tag);\n  head = null;\n  tag = null;\n}\nfunction onAPIready$1(callback) {\n  // Listen for global YT player callback\n  if ((typeof global$1.YT === 'undefined' || global$1.YT.loaded === 0) && !loadingYoutubePlayer) {\n    // Prevents Ready event from being called twice\n    loadingYoutubePlayer = 1;\n\n    // Creates deferred so, other players know when to wait.\n    global$1.onYouTubeIframeAPIReady = function () {\n      global$1.onYouTubeIframeAPIReady = null;\n      loadingYoutubeDefer.resolve('done');\n      callback();\n    };\n  } else if (typeof global$1.YT === 'object' && global$1.YT.loaded === 1) {\n    callback();\n  } else {\n    loadingYoutubeDefer.done(() => {\n      callback();\n    });\n  }\n}\nclass VideoWorkerYoutube extends VideoWorkerBase {\n  type = 'youtube';\n  static parseURL(url) {\n    // eslint-disable-next-line no-useless-escape\n    const regExp = /.*(?:youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|shorts\\/|watch\\?v=)([^#\\&\\?]*).*/;\n    const match = url.match(regExp);\n    return match && match[1].length === 11 ? match[1] : false;\n  }\n  init() {\n    super.init();\n    loadAPI$1();\n  }\n  play(start) {\n    const self = this;\n    if (!self.player || !self.player.playVideo) {\n      return;\n    }\n    if (typeof start !== 'undefined') {\n      self.player.seekTo(start || 0);\n    }\n    if (global$1.YT.PlayerState.PLAYING !== self.player.getPlayerState()) {\n      // Don't play if video is already ended and with no loop.\n      if (self.options.endTime && !self.options.loop) {\n        self.getCurrentTime(seconds => {\n          if (seconds < self.options.endTime) {\n            self.player.playVideo();\n          }\n        });\n      } else {\n        self.player.playVideo();\n      }\n    }\n  }\n  pause() {\n    const self = this;\n    if (!self.player || !self.player.pauseVideo) {\n      return;\n    }\n    if (global$1.YT.PlayerState.PLAYING === self.player.getPlayerState()) {\n      self.player.pauseVideo();\n    }\n  }\n  mute() {\n    const self = this;\n    if (!self.player || !self.player.mute) {\n      return;\n    }\n    self.player.mute();\n  }\n  unmute() {\n    const self = this;\n    if (!self.player || !self.player.unMute) {\n      return;\n    }\n    self.player.unMute();\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number' || !self.player.setVolume) {\n      return;\n    }\n    self.player.setVolume(volume);\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    if (self.player.getVolume) {\n      callback(self.player.getVolume());\n    }\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    if (self.player.isMuted) {\n      callback(self.player.isMuted());\n    }\n  }\n  setCurrentTime(currentTime = false) {\n    const self = this;\n    if (!self.player || typeof currentTime !== 'number' || !self.player.seekTo) {\n      return;\n    }\n    self.player.seekTo(currentTime);\n  }\n  getCurrentTime(callback) {\n    const self = this;\n    if (!self.player || !self.player.getCurrentTime) {\n      return;\n    }\n    callback(self.player.getCurrentTime());\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n      return;\n    }\n    const availableSizes = ['maxresdefault', 'sddefault', 'hqdefault', '0'];\n    let step = 0;\n    const tempImg = new Image();\n    tempImg.onload = function () {\n      // if no thumbnail, youtube add their own image with width = 120px\n      if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {\n        // ok\n        self.videoImage = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n        callback(self.videoImage);\n      } else {\n        // try another size\n        step += 1;\n        this.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n      }\n    };\n    tempImg.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    onAPIready$1(() => {\n      let hiddenDiv;\n      if (!self.$video) {\n        hiddenDiv = document.createElement('div');\n        hiddenDiv.style.display = 'none';\n      }\n      self.playerOptions = {\n        // GDPR Compliance.\n        host: 'https://www.youtube-nocookie.com',\n        videoId: self.videoID,\n        playerVars: {\n          autohide: 1,\n          rel: 0,\n          autoplay: 0,\n          // autoplay enable on mobile devices\n          playsinline: 1\n        }\n      };\n\n      // hide controls\n      if (!self.options.showControls) {\n        self.playerOptions.playerVars.iv_load_policy = 3;\n        self.playerOptions.playerVars.modestbranding = 1;\n        self.playerOptions.playerVars.controls = 0;\n        self.playerOptions.playerVars.showinfo = 0;\n        self.playerOptions.playerVars.disablekb = 1;\n      }\n\n      // events\n      let ytStarted;\n      let ytProgressInterval;\n      self.playerOptions.events = {\n        onReady(e) {\n          // mute\n          if (self.options.mute) {\n            e.target.mute();\n          } else if (typeof self.options.volume === 'number') {\n            e.target.setVolume(self.options.volume);\n          }\n\n          // autoplay\n          if (self.options.autoplay) {\n            self.play(self.options.startTime);\n          }\n          self.fire('ready', e);\n\n          // For seamless loops, set the endTime to 0.1 seconds less than the video's duration\n          // https://github.com/nk-o/video-worker/issues/2\n          if (self.options.loop && !self.options.endTime) {\n            const secondsOffset = 0.1;\n            self.options.endTime = self.player.getDuration() - secondsOffset;\n          }\n\n          // volumechange\n          setInterval(() => {\n            self.getVolume(volume => {\n              if (self.options.volume !== volume) {\n                self.options.volume = volume;\n                self.fire('volumechange', e);\n              }\n            });\n          }, 150);\n        },\n        onStateChange(e) {\n          // loop\n          if (self.options.loop && e.data === global$1.YT.PlayerState.ENDED) {\n            self.play(self.options.startTime);\n          }\n          if (!ytStarted && e.data === global$1.YT.PlayerState.PLAYING) {\n            ytStarted = 1;\n            self.fire('started', e);\n          }\n          if (e.data === global$1.YT.PlayerState.PLAYING) {\n            self.fire('play', e);\n          }\n          if (e.data === global$1.YT.PlayerState.PAUSED) {\n            self.fire('pause', e);\n          }\n          if (e.data === global$1.YT.PlayerState.ENDED) {\n            self.fire('ended', e);\n          }\n\n          // progress check\n          if (e.data === global$1.YT.PlayerState.PLAYING) {\n            ytProgressInterval = setInterval(() => {\n              self.fire('timeupdate', e);\n\n              // check for end of video and play again or stop\n              if (self.options.endTime && self.player.getCurrentTime() >= self.options.endTime) {\n                if (self.options.loop) {\n                  self.play(self.options.startTime);\n                } else {\n                  self.pause();\n                }\n              }\n            }, 150);\n          } else {\n            clearInterval(ytProgressInterval);\n          }\n        },\n        onError(e) {\n          self.fire('error', e);\n        }\n      };\n      const firstInit = !self.$video;\n      if (firstInit) {\n        const div = document.createElement('div');\n        div.setAttribute('id', self.playerID);\n        hiddenDiv.appendChild(div);\n        document.body.appendChild(hiddenDiv);\n      }\n      self.player = self.player || new global$1.YT.Player(self.playerID, self.playerOptions);\n      if (firstInit) {\n        self.$video = document.getElementById(self.playerID);\n\n        // add accessibility attributes\n        if (self.options.accessibilityHidden) {\n          self.$video.setAttribute('tabindex', '-1');\n          self.$video.setAttribute('aria-hidden', 'true');\n        }\n\n        // get video width and height\n        self.videoWidth = parseInt(self.$video.getAttribute('width'), 10) || 1280;\n        self.videoHeight = parseInt(self.$video.getAttribute('height'), 10) || 720;\n      }\n      callback(self.$video);\n    });\n  }\n}\nlet VimeoAPIadded = 0;\nlet loadingVimeoPlayer = 0;\nconst loadingVimeoDefer = /*#__PURE__*/new Deferred();\nfunction loadAPI() {\n  if (VimeoAPIadded) {\n    return;\n  }\n  VimeoAPIadded = true;\n\n  // Useful when Vimeo API added using RequireJS https://github.com/nk-o/video-worker/pull/7\n  if (typeof global$1.Vimeo !== 'undefined') {\n    return;\n  }\n  const src = 'https://player.vimeo.com/api/player.js';\n\n  // add script in head section\n  let tag = document.createElement('script');\n  let head = document.getElementsByTagName('head')[0];\n  tag.src = src;\n  head.appendChild(tag);\n  head = null;\n  tag = null;\n}\nfunction onAPIready(callback) {\n  if (typeof global$1.Vimeo === 'undefined' && !loadingVimeoPlayer) {\n    loadingVimeoPlayer = 1;\n    const vimeoInterval = setInterval(() => {\n      if (typeof global$1.Vimeo !== 'undefined') {\n        clearInterval(vimeoInterval);\n        loadingVimeoDefer.resolve('done');\n        callback();\n      }\n    }, 20);\n  } else if (typeof global$1.Vimeo !== 'undefined') {\n    callback();\n  } else {\n    loadingVimeoDefer.done(() => {\n      callback();\n    });\n  }\n}\nclass VideoWorkerVimeo extends VideoWorkerBase {\n  type = 'vimeo';\n  static parseURL(url) {\n    // eslint-disable-next-line no-useless-escape\n    const regExp = /https?:\\/\\/(?:www\\.|player\\.)?vimeo.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|album\\/(\\d+)\\/video\\/|video\\/|)(\\d+)(?:$|\\/|\\?)/;\n    const match = url.match(regExp);\n    return match && match[3] ? match[3] : false;\n  }\n\n  // Try to extract a hash for private videos from the URL.\n  // Thanks to https://github.com/sampotts/plyr\n  static parseURLHash(url) {\n    /* This regex matches a hexadecimal hash if given in any of these forms:\n     *  - [https://player.]vimeo.com/video/{id}/{hash}[?params]\n     *  - [https://player.]vimeo.com/video/{id}?h={hash}[&params]\n     *  - [https://player.]vimeo.com/video/{id}?[params]&h={hash}\n     *  - video/{id}/{hash}\n     * If matched, the hash is available in capture group 4\n     */\n    const regex = /^.*(vimeo.com\\/|video\\/)(\\d+)(\\?.*&*h=|\\/)+([\\d,a-f]+)/;\n    const found = url.match(regex);\n    return found && found.length === 5 ? found[4] : null;\n  }\n  init() {\n    super.init();\n    loadAPI();\n  }\n  play(start) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (typeof start !== 'undefined') {\n      self.player.setCurrentTime(start);\n    }\n    self.player.getPaused().then(paused => {\n      if (paused) {\n        // Don't play if video is already ended and with no loop.\n        if (self.options.endTime && !self.options.loop) {\n          self.getCurrentTime(seconds => {\n            if (seconds < self.options.endTime) {\n              self.player.play();\n            }\n          });\n        } else {\n          self.player.play();\n        }\n      }\n    });\n  }\n  pause() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    self.player.getPaused().then(paused => {\n      if (!paused) {\n        self.player.pause();\n      }\n    });\n  }\n  mute() {\n    const self = this;\n    if (!self.player || !self.player.setVolume) {\n      return;\n    }\n    self.setVolume(0);\n  }\n  unmute() {\n    const self = this;\n    if (!self.player || !self.player.setVolume) {\n      return;\n    }\n\n    // In case the default volume is 0, we have to set 100 when unmute.\n    self.setVolume(self.options.volume || 100);\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number' || !self.player.setVolume) {\n      return;\n    }\n    self.player.setVolume(volume / 100);\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    if (self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(volume * 100);\n      });\n    }\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    if (self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(!!volume);\n      });\n    }\n  }\n  setCurrentTime(currentTime = false) {\n    const self = this;\n    if (!self.player || typeof currentTime !== 'number' || !self.player.setCurrentTime) {\n      return;\n    }\n    self.player.setCurrentTime(currentTime);\n  }\n  getCurrentTime(callback) {\n    const self = this;\n    if (!self.player || !self.player.getCurrentTime) {\n      return;\n    }\n    self.player.getCurrentTime().then(currentTime => {\n      callback(currentTime);\n    });\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n      return;\n    }\n\n    // We should provide width to get HQ thumbnail URL.\n    let width = global$1.innerWidth || 1920;\n    if (global$1.devicePixelRatio) {\n      width *= global$1.devicePixelRatio;\n    }\n    width = Math.min(width, 1920);\n    let request = new XMLHttpRequest();\n    // https://vimeo.com/api/oembed.json?url=https://vimeo.com/235212527\n    request.open('GET', `https://vimeo.com/api/oembed.json?url=${self.url}&width=${width}`, true);\n    request.onreadystatechange = function () {\n      if (this.readyState === 4) {\n        if (this.status >= 200 && this.status < 400) {\n          // Success!\n          const response = JSON.parse(this.responseText);\n          if (response.thumbnail_url) {\n            self.videoImage = response.thumbnail_url;\n            callback(self.videoImage);\n          }\n        }\n      }\n    };\n    request.send();\n    request = null;\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    onAPIready(() => {\n      let hiddenDiv;\n      if (!self.$video) {\n        hiddenDiv = document.createElement('div');\n        hiddenDiv.style.display = 'none';\n      }\n      self.playerOptions = {\n        // GDPR Compliance.\n        dnt: 1,\n        id: self.videoID,\n        autopause: 0,\n        transparent: 0,\n        autoplay: self.options.autoplay ? 1 : 0,\n        loop: self.options.loop ? 1 : 0,\n        muted: self.options.mute || self.options.volume === 0 ? 1 : 0\n      };\n\n      // private video hash\n      const urlHash = self.constructor.parseURLHash(self.url);\n      if (urlHash) {\n        self.playerOptions.h = urlHash;\n      }\n\n      // hide controls\n      if (!self.options.showControls) {\n        self.playerOptions.controls = 0;\n      }\n\n      // enable background option\n      if (!self.options.showControls && self.options.loop && self.options.autoplay) {\n        self.playerOptions.background = 1;\n      }\n      if (!self.$video) {\n        let playerOptionsString = '';\n        Object.keys(self.playerOptions).forEach(key => {\n          if (playerOptionsString !== '') {\n            playerOptionsString += '&';\n          }\n          playerOptionsString += `${key}=${encodeURIComponent(self.playerOptions[key])}`;\n        });\n\n        // we need to create iframe manually because when we create it using API\n        // js events won't triggers after iframe moved to another place\n        self.$video = document.createElement('iframe');\n        self.$video.setAttribute('id', self.playerID);\n        self.$video.setAttribute('src', `https://player.vimeo.com/video/${self.videoID}?${playerOptionsString}`);\n        self.$video.setAttribute('frameborder', '0');\n        self.$video.setAttribute('mozallowfullscreen', '');\n        self.$video.setAttribute('allowfullscreen', '');\n        self.$video.setAttribute('title', 'Vimeo video player');\n\n        // add accessibility attributes\n        if (self.options.accessibilityHidden) {\n          self.$video.setAttribute('tabindex', '-1');\n          self.$video.setAttribute('aria-hidden', 'true');\n        }\n        hiddenDiv.appendChild(self.$video);\n        document.body.appendChild(hiddenDiv);\n      }\n      self.player = self.player || new global$1.Vimeo.Player(self.$video, self.playerOptions);\n\n      // Since Vimeo removed the `volume` parameter, we have to set it manually.\n      if (!self.options.mute && typeof self.options.volume === 'number') {\n        self.setVolume(self.options.volume);\n      }\n\n      // set current time for autoplay\n      if (self.options.startTime && self.options.autoplay) {\n        self.player.setCurrentTime(self.options.startTime);\n      }\n\n      // get video width and height\n      self.player.getVideoWidth().then(width => {\n        self.videoWidth = width || 1280;\n      });\n      self.player.getVideoHeight().then(height => {\n        self.videoHeight = height || 720;\n      });\n\n      // events\n      let vmStarted;\n      self.player.on('timeupdate', e => {\n        if (!vmStarted) {\n          self.fire('started', e);\n          vmStarted = 1;\n        }\n        self.fire('timeupdate', e);\n\n        // check for end of video and play again or stop\n        if (self.options.endTime && e.seconds >= self.options.endTime) {\n          if (self.options.loop) {\n            self.play(self.options.startTime);\n          } else {\n            self.pause();\n          }\n        }\n      });\n      self.player.on('play', e => {\n        self.fire('play', e);\n\n        // check for the start time and start with it\n        if (self.options.startTime && e.seconds === 0) {\n          self.play(self.options.startTime);\n        }\n      });\n      self.player.on('pause', e => {\n        self.fire('pause', e);\n      });\n      self.player.on('ended', e => {\n        self.fire('ended', e);\n      });\n      self.player.on('loaded', e => {\n        self.fire('ready', e);\n      });\n      self.player.on('volumechange', e => {\n        self.getVolume(volume => {\n          self.options.volume = volume;\n        });\n        self.fire('volumechange', e);\n      });\n      self.player.on('error', e => {\n        self.fire('error', e);\n      });\n      callback(self.$video);\n    });\n  }\n}\nclass VideoWorkerLocal extends VideoWorkerBase {\n  type = 'local';\n  static parseURL(url) {\n    // eslint-disable-next-line no-useless-escape\n    const videoFormats = url.split(/,(?=mp4\\:|webm\\:|ogv\\:|ogg\\:)/);\n    const result = {};\n    let ready = 0;\n    videoFormats.forEach(val => {\n      // eslint-disable-next-line no-useless-escape\n      const match = val.match(/^(mp4|webm|ogv|ogg)\\:(.*)/);\n      if (match && match[1] && match[2]) {\n        // eslint-disable-next-line prefer-destructuring\n        result[match[1] === 'ogv' ? 'ogg' : match[1]] = match[2];\n        ready = 1;\n      }\n    });\n    return ready ? result : false;\n  }\n  play(start) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (typeof start !== 'undefined') {\n      self.player.currentTime = start;\n    }\n    if (self.player.paused) {\n      // Don't play if video is already ended and with no loop.\n      if (self.options.endTime && !self.options.loop) {\n        self.getCurrentTime(seconds => {\n          if (seconds < self.options.endTime) {\n            self.player.play();\n          }\n        });\n      } else {\n        self.player.play();\n      }\n    }\n  }\n  pause() {\n    const self = this;\n    if (!self.player || self.player.paused) {\n      return;\n    }\n    self.player.pause();\n  }\n  mute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    self.$video.muted = true;\n  }\n  unmute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    self.$video.muted = false;\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number') {\n      return;\n    }\n    self.$video.volume = volume / 100;\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    callback(self.$video.volume * 100);\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    callback(self.$video.muted);\n  }\n  setCurrentTime(currentTime = false) {\n    const self = this;\n    if (!self.player || typeof currentTime !== 'number') {\n      return;\n    }\n    self.$video.currentTime = currentTime;\n  }\n  getCurrentTime(callback) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    callback(self.player.currentTime);\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n    }\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    let hiddenDiv;\n    if (!self.$video) {\n      hiddenDiv = document.createElement('div');\n      hiddenDiv.style.display = 'none';\n    }\n    function addSourceElement(element, src, type) {\n      const source = document.createElement('source');\n      source.src = src;\n      source.type = type;\n      element.appendChild(source);\n    }\n    if (!self.$video) {\n      self.$video = document.createElement('video');\n      self.player = self.$video;\n\n      // show controls\n      if (self.options.showControls) {\n        self.$video.controls = true;\n      }\n\n      // set volume\n      if (typeof self.options.volume === 'number') {\n        self.setVolume(self.options.volume);\n      }\n\n      // mute (it is required to mute after the volume set)\n      if (self.options.mute) {\n        self.mute();\n      }\n\n      // loop\n      if (self.options.loop) {\n        self.$video.loop = true;\n      }\n\n      // autoplay enable on mobile devices\n      self.$video.setAttribute('playsinline', '');\n      self.$video.setAttribute('webkit-playsinline', '');\n\n      // add accessibility attributes\n      if (self.options.accessibilityHidden) {\n        self.$video.setAttribute('tabindex', '-1');\n        self.$video.setAttribute('aria-hidden', 'true');\n      }\n      self.$video.setAttribute('id', self.playerID);\n      hiddenDiv.appendChild(self.$video);\n      document.body.appendChild(hiddenDiv);\n      Object.keys(self.videoID).forEach(key => {\n        addSourceElement(self.$video, self.videoID[key], `video/${key}`);\n      });\n    }\n    let locStarted;\n    self.player.addEventListener('playing', e => {\n      if (!locStarted) {\n        self.fire('started', e);\n      }\n      locStarted = 1;\n    });\n    self.player.addEventListener('timeupdate', function (e) {\n      self.fire('timeupdate', e);\n\n      // check for end of video and play again or stop\n      if (self.options.endTime && this.currentTime >= self.options.endTime) {\n        if (self.options.loop) {\n          self.play(self.options.startTime);\n        } else {\n          self.pause();\n        }\n      }\n    });\n    self.player.addEventListener('play', e => {\n      self.fire('play', e);\n    });\n    self.player.addEventListener('pause', e => {\n      self.fire('pause', e);\n    });\n    self.player.addEventListener('ended', e => {\n      self.fire('ended', e);\n    });\n    self.player.addEventListener('loadedmetadata', function () {\n      // get video width and height\n      self.videoWidth = this.videoWidth || 1280;\n      self.videoHeight = this.videoHeight || 720;\n      self.fire('ready');\n\n      // autoplay\n      if (self.options.autoplay) {\n        self.play(self.options.startTime);\n      }\n    });\n    self.player.addEventListener('volumechange', e => {\n      self.getVolume(volume => {\n        self.options.volume = volume;\n      });\n      self.fire('volumechange', e);\n    });\n    self.player.addEventListener('error', e => {\n      self.fire('error', e);\n    });\n    callback(self.$video);\n  }\n}\nfunction VideoWorker(url, options) {\n  let result = false;\n  Object.keys(VideoWorker.providers).forEach(key => {\n    if (!result && VideoWorker.providers[key].parseURL(url)) {\n      result = new VideoWorker.providers[key](url, options);\n    }\n  });\n  return result || new VideoWorkerBase(url, options);\n}\nVideoWorker.BaseClass = VideoWorkerBase;\nVideoWorker.providers = {\n  Youtube: VideoWorkerYoutube,\n  Vimeo: VideoWorkerVimeo,\n  Local: VideoWorkerLocal\n};\n\nfunction jarallaxVideo$1(jarallax = global$2.jarallax) {\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n  const Jarallax = jarallax.constructor;\n\n  // append video after when block will be visible.\n  const defOnScroll = Jarallax.prototype.onScroll;\n  Jarallax.prototype.onScroll = function () {\n    const self = this;\n    defOnScroll.apply(self);\n    const isReady = !self.isVideoInserted && self.video && (!self.options.videoLazyLoading || self.isElementInViewport) && !self.options.disableVideo();\n    if (isReady) {\n      self.isVideoInserted = true;\n      self.video.getVideo(video => {\n        const $parent = video.parentNode;\n        self.css(video, {\n          position: self.image.position,\n          top: '0px',\n          left: '0px',\n          right: '0px',\n          bottom: '0px',\n          width: '100%',\n          height: '100%',\n          maxWidth: 'none',\n          maxHeight: 'none',\n          pointerEvents: 'none',\n          transformStyle: 'preserve-3d',\n          backfaceVisibility: 'hidden',\n          margin: 0,\n          zIndex: -1\n        });\n        self.$video = video;\n\n        // add Poster attribute to self-hosted video\n        if (self.video.type === 'local') {\n          if (self.image.src) {\n            self.$video.setAttribute('poster', self.image.src);\n          } else if (self.image.$item && self.image.$item.tagName === 'IMG' && self.image.$item.src) {\n            self.$video.setAttribute('poster', self.image.$item.src);\n          }\n        }\n\n        // add classname to video element\n        if (self.options.videoClass) {\n          self.$video.setAttribute('class', `${self.options.videoClass} ${self.options.videoClass}-${self.video.type}`);\n        }\n\n        // insert video tag\n        self.image.$container.appendChild(video);\n\n        // remove parent video element (created by VideoWorker)\n        $parent.parentNode.removeChild($parent);\n\n        // call onVideoInsert event\n        if (self.options.onVideoInsert) {\n          self.options.onVideoInsert.call(self);\n        }\n      });\n    }\n  };\n\n  // cover video\n  const defCoverImage = Jarallax.prototype.coverImage;\n  Jarallax.prototype.coverImage = function () {\n    const self = this;\n    const imageData = defCoverImage.apply(self);\n    const node = self.image.$item ? self.image.$item.nodeName : false;\n    if (imageData && self.video && node && (node === 'IFRAME' || node === 'VIDEO')) {\n      let h = imageData.image.height;\n      let w = h * self.image.width / self.image.height;\n      let ml = (imageData.container.width - w) / 2;\n      let mt = imageData.image.marginTop;\n      if (imageData.container.width > w) {\n        w = imageData.container.width;\n        h = w * self.image.height / self.image.width;\n        ml = 0;\n        mt += (imageData.image.height - h) / 2;\n      }\n\n      // add video height over than need to hide controls\n      if (node === 'IFRAME') {\n        h += 400;\n        mt -= 200;\n      }\n      self.css(self.$video, {\n        width: `${w}px`,\n        marginLeft: `${ml}px`,\n        height: `${h}px`,\n        marginTop: `${mt}px`\n      });\n    }\n    return imageData;\n  };\n\n  // init video\n  const defInitImg = Jarallax.prototype.initImg;\n  Jarallax.prototype.initImg = function () {\n    const self = this;\n    const defaultResult = defInitImg.apply(self);\n    if (!self.options.videoSrc) {\n      self.options.videoSrc = self.$item.getAttribute('data-jarallax-video') || null;\n    }\n    if (self.options.videoSrc) {\n      self.defaultInitImgResult = defaultResult;\n      return true;\n    }\n    return defaultResult;\n  };\n  const defCanInitParallax = Jarallax.prototype.canInitParallax;\n  Jarallax.prototype.canInitParallax = function () {\n    const self = this;\n    let defaultResult = defCanInitParallax.apply(self);\n    if (!self.options.videoSrc) {\n      return defaultResult;\n    }\n\n    // Init video api\n    const video = new VideoWorker(self.options.videoSrc, {\n      autoplay: true,\n      loop: self.options.videoLoop,\n      showControls: false,\n      accessibilityHidden: true,\n      startTime: self.options.videoStartTime || 0,\n      endTime: self.options.videoEndTime || 0,\n      mute: !self.options.videoVolume,\n      volume: self.options.videoVolume || 0\n    });\n\n    // call onVideoWorkerInit event\n    if (self.options.onVideoWorkerInit) {\n      self.options.onVideoWorkerInit.call(self, video);\n    }\n    function resetDefaultImage() {\n      if (self.image.$default_item) {\n        self.image.$item = self.image.$default_item;\n        self.image.$item.style.display = 'block';\n\n        // set image width and height\n        self.coverImage();\n        self.onScroll();\n      }\n    }\n    if (video.isValid()) {\n      // Force enable parallax.\n      // When the parallax disabled on mobile devices, we still need to display videos.\n      // https://github.com/nk-o/jarallax/issues/159\n      if (this.options.disableParallax()) {\n        defaultResult = true;\n        self.image.position = 'absolute';\n        self.options.type = 'scroll';\n        self.options.speed = 1;\n      }\n\n      // if parallax will not be inited, we can add thumbnail on background.\n      if (!defaultResult) {\n        if (!self.defaultInitImgResult) {\n          video.getImageURL(url => {\n            // save default user styles\n            const curStyle = self.$item.getAttribute('style');\n            if (curStyle) {\n              self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n            }\n\n            // set new background\n            self.css(self.$item, {\n              'background-image': `url(\"${url}\")`,\n              'background-position': 'center',\n              'background-size': 'cover'\n            });\n          });\n        }\n\n        // init video\n      } else {\n        video.on('ready', () => {\n          if (self.options.videoPlayOnlyVisible) {\n            const oldOnScroll = self.onScroll;\n            self.onScroll = function () {\n              oldOnScroll.apply(self);\n              if (!self.videoError && (self.options.videoLoop || !self.options.videoLoop && !self.videoEnded)) {\n                if (self.isVisible()) {\n                  video.play();\n                } else {\n                  video.pause();\n                }\n              }\n            };\n          } else {\n            video.play();\n          }\n        });\n        video.on('started', () => {\n          self.image.$default_item = self.image.$item;\n          self.image.$item = self.$video;\n\n          // set video width and height\n          self.image.width = self.video.videoWidth || 1280;\n          self.image.height = self.video.videoHeight || 720;\n          self.coverImage();\n          self.onScroll();\n\n          // hide image\n          if (self.image.$default_item) {\n            self.image.$default_item.style.display = 'none';\n          }\n        });\n        video.on('ended', () => {\n          self.videoEnded = true;\n          if (!self.options.videoLoop) {\n            // show default image if Loop disabled.\n            resetDefaultImage();\n          }\n        });\n        video.on('error', () => {\n          self.videoError = true;\n\n          // show default image if video loading error.\n          resetDefaultImage();\n        });\n        self.video = video;\n\n        // set image if not exists\n        if (!self.defaultInitImgResult) {\n          // set empty image on self-hosted video if not defined\n          self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n          if (video.type !== 'local') {\n            video.getImageURL(url => {\n              self.image.bgImage = `url(\"${url}\")`;\n              self.init();\n            });\n            return false;\n          }\n        }\n      }\n    }\n    return defaultResult;\n  };\n\n  // Destroy video parallax\n  const defDestroy = Jarallax.prototype.destroy;\n  Jarallax.prototype.destroy = function () {\n    const self = this;\n    if (self.image.$default_item) {\n      self.image.$item = self.image.$default_item;\n      delete self.image.$default_item;\n    }\n    defDestroy.apply(self);\n  };\n}\n\nfunction jarallaxElement$1(jarallax = global$2.jarallax) {\n  // eslint-disable-next-line no-console\n  console.warn(\"Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).\");\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n  const Jarallax = jarallax.constructor;\n\n  // redefine default methods\n  ['initImg', 'canInitParallax', 'init', 'destroy', 'coverImage', 'isVisible', 'onScroll', 'onResize'].forEach(key => {\n    const def = Jarallax.prototype[key];\n    Jarallax.prototype[key] = function (...args) {\n      const self = this;\n      if (key === 'initImg' && self.$item.getAttribute('data-jarallax-element') !== null) {\n        self.options.type = 'element';\n        self.pureOptions.speed = self.$item.getAttribute('data-jarallax-element') || '100';\n      }\n      if (self.options.type !== 'element') {\n        return def.apply(self, args);\n      }\n      self.pureOptions.threshold = self.$item.getAttribute('data-threshold') || '';\n      switch (key) {\n        case 'init':\n          {\n            const speedArr = `${self.pureOptions.speed}`.split(' ');\n            self.options.speed = self.pureOptions.speed || 0;\n            self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;\n            self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;\n            const thresholdArr = self.pureOptions.threshold.split(' ');\n            self.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;\n            self.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;\n            def.apply(self, args);\n\n            // restore background image if available.\n            const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n            if (originalStylesTag) {\n              self.$item.setAttribute('style', originalStylesTag);\n            }\n            return true;\n          }\n        case 'onResize':\n          {\n            const defTransform = self.css(self.$item, 'transform');\n            self.css(self.$item, {\n              transform: ''\n            });\n            const rect = self.$item.getBoundingClientRect();\n            self.itemData = {\n              width: rect.width,\n              height: rect.height,\n              y: rect.top + self.getWindowData().y,\n              x: rect.left\n            };\n            self.css(self.$item, {\n              transform: defTransform\n            });\n            break;\n          }\n        case 'onScroll':\n          {\n            const wnd = self.getWindowData();\n            const centerPercent = (wnd.y + wnd.height / 2 - self.itemData.y - self.itemData.height / 2) / (wnd.height / 2);\n            const moveY = centerPercent * self.options.speedY;\n            const moveX = centerPercent * self.options.speedX;\n            let my = moveY;\n            let mx = moveX;\n            if (self.options.thresholdY !== null && moveY > self.options.thresholdY) my = 0;\n            if (self.options.thresholdX !== null && moveX > self.options.thresholdX) mx = 0;\n            self.css(self.$item, {\n              transform: `translate3d(${mx}px,${my}px,0)`\n            });\n            break;\n          }\n        case 'initImg':\n        case 'isVisible':\n        case 'coverImage':\n          return true;\n        // no default\n      }\n      return def.apply(self, args);\n    };\n  });\n}\n\nconst jarallax = jarallax$1;\nconst jarallaxVideo = function jarallaxVideo() {\n  return jarallaxVideo$1(jarallax);\n};\nconst jarallaxElement = function jarallaxElement() {\n  return jarallaxElement$1(jarallax);\n};\n\n\n//# sourceMappingURL=jarallax.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamFyYWxsYXgvZGlzdC9qYXJhbGxheC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYyxTQUFTLGVBQWUsU0FBUztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUM7QUFDakMscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLG1FQUFtRSxnQkFBZ0I7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZUFBZTtBQUMzRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsb0JBQW9CLFNBQVM7QUFDN0IsaURBQWlELFVBQVU7QUFDM0QsZ0JBQWdCLFdBQVc7QUFDM0IsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYSxHQUFHLHFCQUFxQjtBQUM3RjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsaURBQWlELGFBQWEsR0FBRyxxQkFBcUI7QUFDdEY7QUFDQTtBQUNBLGdEQUFnRCxhQUFhLEdBQUcscUJBQXFCO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsR0FBRyxFQUFFLEtBQUs7QUFDdEQsNENBQTRDLEdBQUcsSUFBSSxLQUFLO0FBQ3hELDRDQUE0QyxHQUFHLGFBQWE7QUFDNUQsaUJBQWlCLEdBQUcsRUFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFNBQVMsU0FBUyxNQUFNO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSSxHQUFHLDRDQUE0QztBQUN2RixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGFBQWEsR0FBRyxvQkFBb0I7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxJQUFJO0FBQ3RFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MseUJBQXlCLEVBQUUsd0JBQXdCLEdBQUcsZ0JBQWdCO0FBQ3JIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEIsdUJBQXVCLEdBQUc7QUFDMUIsbUJBQW1CLEVBQUU7QUFDckIsc0JBQXNCLEdBQUc7QUFDekIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUcsS0FBSyxHQUFHO0FBQ25ELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDcEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2xhay1OZXh0SlMvLi9ub2RlX21vZHVsZXMvamFyYWxsYXgvZGlzdC9qYXJhbGxheC5lc20uanM/NDNiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEphcmFsbGF4IHYyLjIuMSAoaHR0cHM6Ly9naXRodWIuY29tL25rLW8vamFyYWxsYXgpXG4gKiBDb3B5cmlnaHQgMjAyNCBuSyA8aHR0cHM6Ly9ua2Rldi5pbmZvPlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmstby9qYXJhbGxheC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG52YXIgZGVmYXVsdHMkMSA9IHtcbiAgLy8gQmFzZSBwYXJhbGxheCBvcHRpb25zLlxuICB0eXBlOiAnc2Nyb2xsJyxcbiAgc3BlZWQ6IDAuNSxcbiAgY29udGFpbmVyQ2xhc3M6ICdqYXJhbGxheC1jb250YWluZXInLFxuICBpbWdTcmM6IG51bGwsXG4gIGltZ0VsZW1lbnQ6ICcuamFyYWxsYXgtaW1nJyxcbiAgaW1nU2l6ZTogJ2NvdmVyJyxcbiAgaW1nUG9zaXRpb246ICc1MCUgNTAlJyxcbiAgaW1nUmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAga2VlcEltZzogZmFsc2UsXG4gIGVsZW1lbnRJblZpZXdwb3J0OiBudWxsLFxuICB6SW5kZXg6IC0xMDAsXG4gIGRpc2FibGVQYXJhbGxheDogZmFsc2UsXG4gIC8vIENhbGxiYWNrcy5cbiAgb25TY3JvbGw6IG51bGwsXG4gIG9uSW5pdDogbnVsbCxcbiAgb25EZXN0cm95OiBudWxsLFxuICBvbkNvdmVySW1hZ2U6IG51bGwsXG4gIC8vIFZpZGVvIG9wdGlvbnMuXG4gIHZpZGVvQ2xhc3M6ICdqYXJhbGxheC12aWRlbycsXG4gIHZpZGVvU3JjOiBudWxsLFxuICB2aWRlb1N0YXJ0VGltZTogMCxcbiAgdmlkZW9FbmRUaW1lOiAwLFxuICB2aWRlb1ZvbHVtZTogMCxcbiAgdmlkZW9Mb29wOiB0cnVlLFxuICB2aWRlb1BsYXlPbmx5VmlzaWJsZTogdHJ1ZSxcbiAgdmlkZW9MYXp5TG9hZGluZzogdHJ1ZSxcbiAgZGlzYWJsZVZpZGVvOiBmYWxzZSxcbiAgLy8gVmlkZW8gY2FsbGJhY2tzLlxuICBvblZpZGVvSW5zZXJ0OiBudWxsLFxuICBvblZpZGVvV29ya2VySW5pdDogbnVsbFxufTtcblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0cyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG5sZXQgd2luJDE7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luJDEgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbiQxID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luJDEgPSBzZWxmO1xufSBlbHNlIHtcbiAgd2luJDEgPSB7fTtcbn1cbnZhciBnbG9iYWwkMiA9IHdpbiQxO1xuXG4vKipcbiAqIEFkZCBzdHlsZXMgdG8gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gc3R5bGVzIC0gc3R5bGVzIGxpc3QuXG4gKlxuICogQHJldHVybnMge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNzcyhlbCwgc3R5bGVzKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnbG9iYWwkMi5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlcyk7XG4gIH1cbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZWwuc3R5bGVba2V5XSA9IHN0eWxlc1trZXldO1xuICB9KTtcbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEV4dGVuZCBsaWtlIGpRdWVyeS5leHRlbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3V0IC0gb3V0cHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uYW55fSBhcmdzIC0gYWRkaXRpb25hbCBvYmplY3RzIHRvIGV4dGVuZC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBleHRlbmQkMShvdXQsIC4uLmFyZ3MpIHtcbiAgb3V0ID0gb3V0IHx8IHt9O1xuICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKGkgPT4ge1xuICAgIGlmICghYXJnc1tpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhhcmdzW2ldKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBvdXRba2V5XSA9IGFyZ3NbaV1ba2V5XTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2V0IGFsbCBwYXJlbnRzIG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIERPTSBlbGVtZW50LlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50cyhlbGVtKSB7XG4gIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKGVsZW0ucGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGVsZW0gPSBlbGVtLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHBhcmVudHMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmVudHM7XG59XG5cbi8qKlxuICogRG9jdW1lbnQgcmVhZHkgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQgb25jZSBEb2N1bWVudCByZWFkeS5cbiAqL1xuZnVuY3Rpb24gcmVhZHkoY2FsbGJhY2spIHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgIC8vIEFscmVhZHkgcmVhZHkgb3IgaW50ZXJhY3RpdmUsIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYWxsYmFjaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3Qge1xuICBuYXZpZ2F0b3I6IG5hdmlnYXRvciQxXG59ID0gZ2xvYmFsJDI7XG5jb25zdCBtb2JpbGVBZ2VudCA9IC8qI19fUFVSRV9fKi8gL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvciQxLnVzZXJBZ2VudCk7XG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgcmV0dXJuIG1vYmlsZUFnZW50O1xufVxuXG5sZXQgd25kVztcbmxldCB3bmRIO1xubGV0ICRkZXZpY2VIZWxwZXI7XG5cbi8qKlxuICogVGhlIG1vc3QgcG9wdWxhciBtb2JpbGUgYnJvd3NlcnMgY2hhbmdlcyBoZWlnaHQgYWZ0ZXIgcGFnZSBzY3JvbGwgYW5kIHRoaXMgZ2VuZXJhdGVzIGltYWdlIGp1bXBpbmcuXG4gKiBXZSBjYW4gZml4IGl0IHVzaW5nIHRoaXMgd29ya2Fyb3VuZCB3aXRoIHZoIHVuaXRzLlxuICovXG5mdW5jdGlvbiBnZXREZXZpY2VIZWlnaHQoKSB7XG4gIGlmICghJGRldmljZUhlbHBlciAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgJGRldmljZUhlbHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICRkZXZpY2VIZWxwZXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogZml4ZWQ7IHRvcDogLTk5OTlweDsgbGVmdDogMDsgaGVpZ2h0OiAxMDB2aDsgd2lkdGg6IDA7JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCRkZXZpY2VIZWxwZXIpO1xuICB9XG4gIHJldHVybiAoJGRldmljZUhlbHBlciA/ICRkZXZpY2VIZWxwZXIuY2xpZW50SGVpZ2h0IDogMCkgfHwgZ2xvYmFsJDIuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVdpbmRvd0hlaWdodCgpIHtcbiAgd25kVyA9IGdsb2JhbCQyLmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICBpZiAoaXNNb2JpbGUoKSkge1xuICAgIHduZEggPSBnZXREZXZpY2VIZWlnaHQoKTtcbiAgfSBlbHNlIHtcbiAgICB3bmRIID0gZ2xvYmFsJDIuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxufVxudXBkYXRlV2luZG93SGVpZ2h0KCk7XG5nbG9iYWwkMi5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVXaW5kb3dIZWlnaHQpO1xuZ2xvYmFsJDIuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB1cGRhdGVXaW5kb3dIZWlnaHQpO1xuZ2xvYmFsJDIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHVwZGF0ZVdpbmRvd0hlaWdodCk7XG5yZWFkeSgoKSA9PiB7XG4gIHVwZGF0ZVdpbmRvd0hlaWdodCgpO1xufSk7XG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplKCkge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3bmRXLFxuICAgIGhlaWdodDogd25kSFxuICB9O1xufVxuXG4vLyBMaXN0IHdpdGggYWxsIGphcmFsbGF4IGluc3RhbmNlc1xuLy8gbmVlZCB0byByZW5kZXIgYWxsIGluIG9uZSBzY3JvbGwvcmVzaXplIGV2ZW50LlxuY29uc3QgamFyYWxsYXhMaXN0ID0gW107XG5mdW5jdGlvbiB1cGRhdGVQYXJhbGxheCgpIHtcbiAgaWYgKCFqYXJhbGxheExpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICB3aWR0aDogd25kVyxcbiAgICBoZWlnaHQ6IHduZEhcbiAgfSA9IGdldFdpbmRvd1NpemUoKTtcbiAgamFyYWxsYXhMaXN0LmZvckVhY2goKGRhdGEsIGspID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBpbnN0YW5jZSxcbiAgICAgIG9sZERhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWluc3RhbmNlLmlzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudFJlY3QgPSBpbnN0YW5jZS4kaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBuZXdEYXRhID0ge1xuICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0LFxuICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCxcbiAgICAgIGJvdHRvbTogY2xpZW50UmVjdC5ib3R0b20sXG4gICAgICB3bmRXLFxuICAgICAgd25kSFxuICAgIH07XG4gICAgY29uc3QgaXNSZXNpemVkID0gIW9sZERhdGEgfHwgb2xkRGF0YS53bmRXICE9PSBuZXdEYXRhLnduZFcgfHwgb2xkRGF0YS53bmRIICE9PSBuZXdEYXRhLnduZEggfHwgb2xkRGF0YS53aWR0aCAhPT0gbmV3RGF0YS53aWR0aCB8fCBvbGREYXRhLmhlaWdodCAhPT0gbmV3RGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgaXNTY3JvbGxlZCA9IGlzUmVzaXplZCB8fCAhb2xkRGF0YSB8fCBvbGREYXRhLnRvcCAhPT0gbmV3RGF0YS50b3AgfHwgb2xkRGF0YS5ib3R0b20gIT09IG5ld0RhdGEuYm90dG9tO1xuICAgIGphcmFsbGF4TGlzdFtrXS5vbGREYXRhID0gbmV3RGF0YTtcbiAgICBpZiAoaXNSZXNpemVkKSB7XG4gICAgICBpbnN0YW5jZS5vblJlc2l6ZSgpO1xuICAgIH1cbiAgICBpZiAoaXNTY3JvbGxlZCkge1xuICAgICAgaW5zdGFuY2Uub25TY3JvbGwoKTtcbiAgICB9XG4gIH0pO1xuICBnbG9iYWwkMi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlUGFyYWxsYXgpO1xufVxuY29uc3QgdmlzaWJpbGl0eU9ic2VydmVyID0gLyojX19QVVJFX18qL25ldyBnbG9iYWwkMi5JbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBlbnRyeS50YXJnZXQuamFyYWxsYXguaXNFbGVtZW50SW5WaWV3cG9ydCA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nO1xuICB9KTtcbn0sIHtcbiAgLy8gV2UgaGF2ZSB0byBzdGFydCBwYXJhbGxheCBjYWxjdWxhdGlvbiBiZWZvcmUgdGhlIGJsb2NrIGlzIGluIHZpZXdcbiAgLy8gdG8gcHJldmVudCBwb3NzaWJsZSBwYXJhbGxheCBqdW1waW5nLlxuICByb290TWFyZ2luOiAnNTBweCdcbn0pO1xuZnVuY3Rpb24gYWRkT2JzZXJ2ZXIoaW5zdGFuY2UpIHtcbiAgamFyYWxsYXhMaXN0LnB1c2goe1xuICAgIGluc3RhbmNlXG4gIH0pO1xuICBpZiAoamFyYWxsYXhMaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIGdsb2JhbCQyLnJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVQYXJhbGxheCk7XG4gIH1cbiAgdmlzaWJpbGl0eU9ic2VydmVyLm9ic2VydmUoaW5zdGFuY2Uub3B0aW9ucy5lbGVtZW50SW5WaWV3cG9ydCB8fCBpbnN0YW5jZS4kaXRlbSk7XG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlcihpbnN0YW5jZSkge1xuICBqYXJhbGxheExpc3QuZm9yRWFjaCgoZGF0YSwga2V5KSA9PiB7XG4gICAgaWYgKGRhdGEuaW5zdGFuY2UuaW5zdGFuY2VJRCA9PT0gaW5zdGFuY2UuaW5zdGFuY2VJRCkge1xuICAgICAgamFyYWxsYXhMaXN0LnNwbGljZShrZXksIDEpO1xuICAgIH1cbiAgfSk7XG4gIHZpc2liaWxpdHlPYnNlcnZlci51bm9ic2VydmUoaW5zdGFuY2Uub3B0aW9ucy5lbGVtZW50SW5WaWV3cG9ydCB8fCBpbnN0YW5jZS4kaXRlbSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmNvbnN0IHtcbiAgbmF2aWdhdG9yXG59ID0gZ2xvYmFsJDI7XG5sZXQgaW5zdGFuY2VJRCA9IDA7XG5cbi8vIEphcmFsbGF4IGNsYXNzXG5jbGFzcyBKYXJhbGxheCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJPcHRpb25zKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5pbnN0YW5jZUlEID0gaW5zdGFuY2VJRDtcbiAgICBpbnN0YW5jZUlEICs9IDE7XG4gICAgc2VsZi4kaXRlbSA9IGl0ZW07XG4gICAgc2VsZi5kZWZhdWx0cyA9IHtcbiAgICAgIC4uLmRlZmF1bHRzJDFcbiAgICB9O1xuXG4gICAgLy8gcHJlcGFyZSBkYXRhLW9wdGlvbnNcbiAgICBjb25zdCBkYXRhT3B0aW9ucyA9IHNlbGYuJGl0ZW0uZGF0YXNldCB8fCB7fTtcbiAgICBjb25zdCBwdXJlRGF0YU9wdGlvbnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhkYXRhT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgbG93ZXJDYXNlT3B0aW9uID0ga2V5LnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpICsga2V5LnN1YnN0cigxKTtcbiAgICAgIGlmIChsb3dlckNhc2VPcHRpb24gJiYgdHlwZW9mIHNlbGYuZGVmYXVsdHNbbG93ZXJDYXNlT3B0aW9uXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHVyZURhdGFPcHRpb25zW2xvd2VyQ2FzZU9wdGlvbl0gPSBkYXRhT3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYub3B0aW9ucyA9IHNlbGYuZXh0ZW5kKHt9LCBzZWxmLmRlZmF1bHRzLCBwdXJlRGF0YU9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICBzZWxmLnB1cmVPcHRpb25zID0gc2VsZi5leHRlbmQoe30sIHNlbGYub3B0aW9ucyk7XG5cbiAgICAvLyBwcmVwYXJlICd0cnVlJyBhbmQgJ2ZhbHNlJyBzdHJpbmdzIHRvIGJvb2xlYW5cbiAgICBPYmplY3Qua2V5cyhzZWxmLm9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChzZWxmLm9wdGlvbnNba2V5XSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHNlbGYub3B0aW9uc1trZXldID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5vcHRpb25zW2tleV0gPT09ICdmYWxzZScpIHtcbiAgICAgICAgc2VsZi5vcHRpb25zW2tleV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpeCBzcGVlZCBvcHRpb24gWy0xLjAsIDIuMF1cbiAgICBzZWxmLm9wdGlvbnMuc3BlZWQgPSBNYXRoLm1pbigyLCBNYXRoLm1heCgtMSwgcGFyc2VGbG9hdChzZWxmLm9wdGlvbnMuc3BlZWQpKSk7XG5cbiAgICAvLyBwcmVwYXJlIGRpc2FibGVQYXJhbGxheCBjYWxsYmFja1xuICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXggPSBuZXcgUmVnRXhwKHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXgpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgY29uc3QgZGlzYWJsZVBhcmFsbGF4UmVnZXhwID0gc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheDtcbiAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXggPSAoKSA9PiBkaXNhYmxlUGFyYWxsYXhSZWdleHAudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBTdXBwb3J0IGZvciBgdHJ1ZWAgb3B0aW9uIHZhbHVlLlxuICAgICAgY29uc3QgZGlzYWJsZVBhcmFsbGF4RGVmYXVsdCA9IHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXg7XG4gICAgICBzZWxmLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4ID0gKCkgPT4gZGlzYWJsZVBhcmFsbGF4RGVmYXVsdCA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGRpc2FibGVWaWRlbyBjYWxsYmFja1xuICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLmRpc2FibGVWaWRlbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8gPSBuZXcgUmVnRXhwKHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8pO1xuICAgIH1cbiAgICBpZiAoc2VsZi5vcHRpb25zLmRpc2FibGVWaWRlbyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgY29uc3QgZGlzYWJsZVZpZGVvUmVnZXhwID0gc2VsZi5vcHRpb25zLmRpc2FibGVWaWRlbztcbiAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8gPSAoKSA9PiBkaXNhYmxlVmlkZW9SZWdleHAudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMuZGlzYWJsZVZpZGVvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBTdXBwb3J0IGZvciBgdHJ1ZWAgb3B0aW9uIHZhbHVlLlxuICAgICAgY29uc3QgZGlzYWJsZVZpZGVvRGVmYXVsdCA9IHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW87XG4gICAgICBzZWxmLm9wdGlvbnMuZGlzYWJsZVZpZGVvID0gKCkgPT4gZGlzYWJsZVZpZGVvRGVmYXVsdCA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBjdXN0b20gZWxlbWVudCB0byBjaGVjayBpZiBwYXJhbGxheCBpbiB2aWV3cG9ydFxuICAgIGxldCBlbGVtZW50SW5WUCA9IHNlbGYub3B0aW9ucy5lbGVtZW50SW5WaWV3cG9ydDtcbiAgICAvLyBnZXQgZmlyc3QgaXRlbSBmcm9tIGFycmF5XG4gICAgaWYgKGVsZW1lbnRJblZQICYmIHR5cGVvZiBlbGVtZW50SW5WUCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGVsZW1lbnRJblZQLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIFtlbGVtZW50SW5WUF0gPSBlbGVtZW50SW5WUDtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgZG9tIGVsZW1lbnRcbiAgICBpZiAoIShlbGVtZW50SW5WUCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50SW5WUCA9IG51bGw7XG4gICAgfVxuICAgIHNlbGYub3B0aW9ucy5lbGVtZW50SW5WaWV3cG9ydCA9IGVsZW1lbnRJblZQO1xuICAgIHNlbGYuaW1hZ2UgPSB7XG4gICAgICBzcmM6IHNlbGYub3B0aW9ucy5pbWdTcmMgfHwgbnVsbCxcbiAgICAgICRjb250YWluZXI6IG51bGwsXG4gICAgICB1c2VJbWdUYWc6IGZhbHNlLFxuICAgICAgLy8gMS4gUG9zaXRpb24gZml4ZWQgaXMgbmVlZGVkIGZvciB0aGUgbW9zdCBvZiBicm93c2VycyBiZWNhdXNlIGFic29sdXRlIHBvc2l0aW9uIGhhdmUgZ2xpdGNoZXNcbiAgICAgIC8vIDIuIE9uIE1hY09TIHdpdGggc21vb3RoIHNjcm9sbCB0aGVyZSBpcyBhIGh1Z2UgbGFncyB3aXRoIGFic29sdXRlIHBvc2l0aW9uIC0gaHR0cHM6Ly9naXRodWIuY29tL25rLW8vamFyYWxsYXgvaXNzdWVzLzc1XG4gICAgICAvLyAzLiBQcmV2aW91c2x5IHVzZWQgJ2Fic29sdXRlJyBmb3IgbW9iaWxlIGRldmljZXMuIEJ1dCB3ZSByZS10ZXN0ZWQgb24gaVBob25lIDEyIGFuZCAnZml4ZWQnIHBvc2l0aW9uIGlzIHdvcmtpbmcgYmV0dGVyLCB0aGVuICdhYnNvbHV0ZScsIHNvIGZvciBub3cgcG9zaXRpb24gaXMgYWx3YXlzICdmaXhlZCdcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnXG4gICAgfTtcbiAgICBpZiAoc2VsZi5pbml0SW1nKCkgJiYgc2VsZi5jYW5Jbml0UGFyYWxsYXgoKSkge1xuICAgICAgc2VsZi5pbml0KCk7XG4gICAgfVxuICB9XG4gIGNzcyhlbCwgc3R5bGVzKSB7XG4gICAgcmV0dXJuIGNzcyhlbCwgc3R5bGVzKTtcbiAgfVxuICBleHRlbmQob3V0LCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGV4dGVuZCQxKG91dCwgLi4uYXJncyk7XG4gIH1cblxuICAvLyBnZXQgd2luZG93IHNpemUgYW5kIHNjcm9sbCBwb3NpdGlvbi4gVXNlZnVsIGZvciBleHRlbnNpb25zXG4gIGdldFdpbmRvd0RhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0V2luZG93U2l6ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHk6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG5cbiAgLy8gSmFyYWxsYXggZnVuY3Rpb25zXG4gIGluaXRJbWcoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBmaW5kIGltYWdlIGVsZW1lbnRcbiAgICBsZXQgJGltZ0VsZW1lbnQgPSBzZWxmLm9wdGlvbnMuaW1nRWxlbWVudDtcbiAgICBpZiAoJGltZ0VsZW1lbnQgJiYgdHlwZW9mICRpbWdFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgJGltZ0VsZW1lbnQgPSBzZWxmLiRpdGVtLnF1ZXJ5U2VsZWN0b3IoJGltZ0VsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGRvbSBlbGVtZW50XG4gICAgaWYgKCEoJGltZ0VsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgaWYgKHNlbGYub3B0aW9ucy5pbWdTcmMpIHtcbiAgICAgICAgJGltZ0VsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgJGltZ0VsZW1lbnQuc3JjID0gc2VsZi5vcHRpb25zLmltZ1NyYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRpbWdFbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpbWdFbGVtZW50KSB7XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmtlZXBJbWcpIHtcbiAgICAgICAgc2VsZi5pbWFnZS4kaXRlbSA9ICRpbWdFbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0gPSAkaW1nRWxlbWVudDtcbiAgICAgICAgc2VsZi5pbWFnZS4kaXRlbVBhcmVudCA9ICRpbWdFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBzZWxmLmltYWdlLnVzZUltZ1RhZyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gdHJ1ZSBpZiB0aGVyZSBpcyBpbWcgdGFnXG4gICAgaWYgKHNlbGYuaW1hZ2UuJGl0ZW0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGdldCBpbWFnZSBzcmNcbiAgICBpZiAoc2VsZi5pbWFnZS5zcmMgPT09IG51bGwpIHtcbiAgICAgIHNlbGYuaW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyc7XG4gICAgICBzZWxmLmltYWdlLmJnSW1hZ2UgPSBzZWxmLmNzcyhzZWxmLiRpdGVtLCAnYmFja2dyb3VuZC1pbWFnZScpO1xuICAgIH1cbiAgICByZXR1cm4gISghc2VsZi5pbWFnZS5iZ0ltYWdlIHx8IHNlbGYuaW1hZ2UuYmdJbWFnZSA9PT0gJ25vbmUnKTtcbiAgfVxuICBjYW5Jbml0UGFyYWxsYXgoKSB7XG4gICAgcmV0dXJuICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4KCk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXJTdHlsZXMgPSB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICB9O1xuICAgIGxldCBpbWFnZVN0eWxlcyA9IHtcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIHRyYW5zZm9ybVN0eWxlOiAncHJlc2VydmUtM2QnLFxuICAgICAgYmFja2ZhY2VWaXNpYmlsaXR5OiAnaGlkZGVuJ1xuICAgIH07XG4gICAgaWYgKCFzZWxmLm9wdGlvbnMua2VlcEltZykge1xuICAgICAgLy8gc2F2ZSBkZWZhdWx0IHVzZXIgc3R5bGVzXG4gICAgICBjb25zdCBjdXJTdHlsZSA9IHNlbGYuJGl0ZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgaWYgKGN1clN0eWxlKSB7XG4gICAgICAgIHNlbGYuJGl0ZW0uc2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LW9yaWdpbmFsLXN0eWxlcycsIGN1clN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmltYWdlLnVzZUltZ1RhZykge1xuICAgICAgICBjb25zdCBjdXJJbWdTdHlsZSA9IHNlbGYuaW1hZ2UuJGl0ZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICBpZiAoY3VySW1nU3R5bGUpIHtcbiAgICAgICAgICBzZWxmLmltYWdlLiRpdGVtLnNldEF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1vcmlnaW5hbC1zdHlsZXMnLCBjdXJJbWdTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgcmVsYXRpdmUgcG9zaXRpb24gYW5kIHotaW5kZXggdG8gdGhlIHBhcmVudFxuICAgIGlmIChzZWxmLmNzcyhzZWxmLiRpdGVtLCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2VsZi5jc3Moc2VsZi4kaXRlbSwgJ3otaW5kZXgnKSA9PT0gJ2F1dG8nKSB7XG4gICAgICBzZWxmLmNzcyhzZWxmLiRpdGVtLCB7XG4gICAgICAgIHpJbmRleDogMFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY29udGFpbmVyIGZvciBwYXJhbGxheCBpbWFnZVxuICAgIHNlbGYuaW1hZ2UuJGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNlbGYuY3NzKHNlbGYuaW1hZ2UuJGNvbnRhaW5lciwgY29udGFpbmVyU3R5bGVzKTtcbiAgICBzZWxmLmNzcyhzZWxmLmltYWdlLiRjb250YWluZXIsIHtcbiAgICAgICd6LWluZGV4Jzogc2VsZi5vcHRpb25zLnpJbmRleFxuICAgIH0pO1xuXG4gICAgLy8gaXQgd2lsbCByZW1vdmUgc29tZSBpbWFnZSBvdmVybGFwcGluZ1xuICAgIC8vIG92ZXJsYXBwaW5nIG9jY3VyIGR1ZSB0byBhbiBpbWFnZSBwb3NpdGlvbiBmaXhlZCBpbnNpZGUgYWJzb2x1dGUgcG9zaXRpb24gZWxlbWVudFxuICAgIC8vIG5lZWRlZCBvbmx5IHdoZW4gYmFja2dyb3VuZCBpbiBmaXhlZCBwb3NpdGlvblxuICAgIGlmICh0aGlzLmltYWdlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBzZWxmLmNzcyhzZWxmLmltYWdlLiRjb250YWluZXIsIHtcbiAgICAgICAgJy13ZWJraXQtY2xpcC1wYXRoJzogJ3BvbHlnb24oMCAwLCAxMDAlIDAsIDEwMCUgMTAwJSwgMCAxMDAlKScsXG4gICAgICAgICdjbGlwLXBhdGgnOiAncG9seWdvbigwIDAsIDEwMCUgMCwgMTAwJSAxMDAlLCAwIDEwMCUpJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGNvbnRhaW5lciB1bmlxdWUgSUQuXG4gICAgc2VsZi5pbWFnZS4kY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCBgamFyYWxsYXgtY29udGFpbmVyLSR7c2VsZi5pbnN0YW5jZUlEfWApO1xuXG4gICAgLy8gQWRkIGNvbnRhaW5lciBjbGFzcy5cbiAgICBpZiAoc2VsZi5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSB7XG4gICAgICBzZWxmLmltYWdlLiRjb250YWluZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsIHNlbGYub3B0aW9ucy5jb250YWluZXJDbGFzcyk7XG4gICAgfVxuICAgIHNlbGYuJGl0ZW0uYXBwZW5kQ2hpbGQoc2VsZi5pbWFnZS4kY29udGFpbmVyKTtcblxuICAgIC8vIHVzZSBpbWcgdGFnXG4gICAgaWYgKHNlbGYuaW1hZ2UudXNlSW1nVGFnKSB7XG4gICAgICBpbWFnZVN0eWxlcyA9IHNlbGYuZXh0ZW5kKHtcbiAgICAgICAgJ29iamVjdC1maXQnOiBzZWxmLm9wdGlvbnMuaW1nU2l6ZSxcbiAgICAgICAgJ29iamVjdC1wb3NpdGlvbic6IHNlbGYub3B0aW9ucy5pbWdQb3NpdGlvbixcbiAgICAgICAgJ21heC13aWR0aCc6ICdub25lJ1xuICAgICAgfSwgY29udGFpbmVyU3R5bGVzLCBpbWFnZVN0eWxlcyk7XG5cbiAgICAgIC8vIHVzZSBkaXYgd2l0aCBiYWNrZ3JvdW5kIGltYWdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGlmIChzZWxmLmltYWdlLnNyYykge1xuICAgICAgICBpbWFnZVN0eWxlcyA9IHNlbGYuZXh0ZW5kKHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbic6IHNlbGYub3B0aW9ucy5pbWdQb3NpdGlvbixcbiAgICAgICAgICAnYmFja2dyb3VuZC1zaXplJzogc2VsZi5vcHRpb25zLmltZ1NpemUsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcmVwZWF0Jzogc2VsZi5vcHRpb25zLmltZ1JlcGVhdCxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IHNlbGYuaW1hZ2UuYmdJbWFnZSB8fCBgdXJsKFwiJHtzZWxmLmltYWdlLnNyY31cIilgXG4gICAgICAgIH0sIGNvbnRhaW5lclN0eWxlcywgaW1hZ2VTdHlsZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZi5vcHRpb25zLnR5cGUgPT09ICdvcGFjaXR5JyB8fCBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3NjYWxlJyB8fCBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3NjYWxlLW9wYWNpdHknIHx8IHNlbGYub3B0aW9ucy5zcGVlZCA9PT0gMSkge1xuICAgICAgc2VsZi5pbWFnZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgfVxuXG4gICAgLy8gMS4gQ2hlY2sgaWYgb25lIG9mIHBhcmVudHMgaGF2ZSB0cmFuc2Zvcm0gc3R5bGUgKHdpdGhvdXQgdGhpcyBjaGVjaywgc2Nyb2xsIHRyYW5zZm9ybSB3aWxsIGJlIGludmVydGVkIGlmIHVzZWQgcGFyYWxsYXggd2l0aCBwb3NpdGlvbiBmaXhlZClcbiAgICAvLyAgICBkaXNjdXNzaW9uIC0gaHR0cHM6Ly9naXRodWIuY29tL25rLW8vamFyYWxsYXgvaXNzdWVzLzlcbiAgICAvLyAyLiBDaGVjayBpZiBwYXJlbnRzIGhhdmUgb3ZlcmZsb3cgc2Nyb2xsXG4gICAgaWYgKHNlbGYuaW1hZ2UucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIGNvbnN0ICRwYXJlbnRzID0gZ2V0UGFyZW50cyhzZWxmLiRpdGVtKS5maWx0ZXIoZWwgPT4ge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBnbG9iYWwkMi5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgY29uc3QgcGFyZW50VHJhbnNmb3JtID0gc3R5bGVzWyctd2Via2l0LXRyYW5zZm9ybSddIHx8IHN0eWxlc1snLW1vei10cmFuc2Zvcm0nXSB8fCBzdHlsZXMudHJhbnNmb3JtO1xuICAgICAgICBjb25zdCBvdmVyZmxvd1JlZ2V4ID0gLyhhdXRvfHNjcm9sbCkvO1xuICAgICAgICByZXR1cm4gcGFyZW50VHJhbnNmb3JtICYmIHBhcmVudFRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IG92ZXJmbG93UmVnZXgudGVzdChzdHlsZXMub3ZlcmZsb3cgKyBzdHlsZXNbJ292ZXJmbG93LXknXSArIHN0eWxlc1snb3ZlcmZsb3cteCddKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5pbWFnZS5wb3NpdGlvbiA9ICRwYXJlbnRzLmxlbmd0aCA/ICdhYnNvbHV0ZScgOiAnZml4ZWQnO1xuICAgIH1cblxuICAgIC8vIGFkZCBwb3NpdGlvbiB0byBwYXJhbGxheCBibG9ja1xuICAgIGltYWdlU3R5bGVzLnBvc2l0aW9uID0gc2VsZi5pbWFnZS5wb3NpdGlvbjtcblxuICAgIC8vIGluc2VydCBwYXJhbGxheCBpbWFnZVxuICAgIHNlbGYuY3NzKHNlbGYuaW1hZ2UuJGl0ZW0sIGltYWdlU3R5bGVzKTtcbiAgICBzZWxmLmltYWdlLiRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5pbWFnZS4kaXRlbSk7XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgIHNlbGYub25SZXNpemUoKTtcbiAgICBzZWxmLm9uU2Nyb2xsKHRydWUpO1xuXG4gICAgLy8gY2FsbCBvbkluaXQgZXZlbnRcbiAgICBpZiAoc2VsZi5vcHRpb25zLm9uSW5pdCkge1xuICAgICAgc2VsZi5vcHRpb25zLm9uSW5pdC5jYWxsKHNlbGYpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBkZWZhdWx0IHVzZXIgYmFja2dyb3VuZFxuICAgIGlmIChzZWxmLmNzcyhzZWxmLiRpdGVtLCAnYmFja2dyb3VuZC1pbWFnZScpICE9PSAnbm9uZScpIHtcbiAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHtcbiAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRPYnNlcnZlcihzZWxmKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJlbW92ZU9ic2VydmVyKHNlbGYpO1xuXG4gICAgLy8gcmV0dXJuIHN0eWxlcyBvbiBjb250YWluZXIgYXMgYmVmb3JlIGphcmFsbGF4IGluaXRcbiAgICBjb25zdCBvcmlnaW5hbFN0eWxlc1RhZyA9IHNlbGYuJGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LW9yaWdpbmFsLXN0eWxlcycpO1xuICAgIHNlbGYuJGl0ZW0ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LW9yaWdpbmFsLXN0eWxlcycpO1xuICAgIC8vIG51bGwgb2NjdXJzIGlmIHRoZXJlIGlzIG5vIHN0eWxlIHRhZyBiZWZvcmUgamFyYWxsYXggaW5pdFxuICAgIGlmICghb3JpZ2luYWxTdHlsZXNUYWcpIHtcbiAgICAgIHNlbGYuJGl0ZW0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLiRpdGVtLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBvcmlnaW5hbFN0eWxlc1RhZyk7XG4gICAgfVxuICAgIGlmIChzZWxmLmltYWdlLnVzZUltZ1RhZykge1xuICAgICAgLy8gcmV0dXJuIHN0eWxlcyBvbiBpbWcgdGFnIGFzIGJlZm9yZSBqYXJhbGxheCBpbml0XG4gICAgICBjb25zdCBvcmlnaW5hbFN0eWxlc0ltZ1RhZyA9IHNlbGYuaW1hZ2UuJGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LW9yaWdpbmFsLXN0eWxlcycpO1xuICAgICAgc2VsZi5pbWFnZS4kaXRlbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJyk7XG4gICAgICAvLyBudWxsIG9jY3VycyBpZiB0aGVyZSBpcyBubyBzdHlsZSB0YWcgYmVmb3JlIGphcmFsbGF4IGluaXRcbiAgICAgIGlmICghb3JpZ2luYWxTdHlsZXNJbWdUYWcpIHtcbiAgICAgICAgc2VsZi5pbWFnZS4kaXRlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmltYWdlLiRpdGVtLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBvcmlnaW5hbFN0eWxlc1RhZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1vdmUgaW1nIHRhZyB0byBpdHMgZGVmYXVsdCBwb3NpdGlvblxuICAgICAgaWYgKHNlbGYuaW1hZ2UuJGl0ZW1QYXJlbnQpIHtcbiAgICAgICAgc2VsZi5pbWFnZS4kaXRlbVBhcmVudC5hcHBlbmRDaGlsZChzZWxmLmltYWdlLiRpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYWRkaXRpb25hbCBkb20gZWxlbWVudHNcbiAgICBpZiAoc2VsZi5pbWFnZS4kY29udGFpbmVyKSB7XG4gICAgICBzZWxmLmltYWdlLiRjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLmltYWdlLiRjb250YWluZXIpO1xuICAgIH1cblxuICAgIC8vIGNhbGwgb25EZXN0cm95IGV2ZW50XG4gICAgaWYgKHNlbGYub3B0aW9ucy5vbkRlc3Ryb3kpIHtcbiAgICAgIHNlbGYub3B0aW9ucy5vbkRlc3Ryb3kuY2FsbChzZWxmKTtcbiAgICB9XG5cbiAgICAvLyBkZWxldGUgamFyYWxsYXggZnJvbSBpdGVtXG4gICAgZGVsZXRlIHNlbGYuJGl0ZW0uamFyYWxsYXg7XG4gIH1cbiAgY292ZXJJbWFnZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQ6IHduZEhcbiAgICB9ID0gZ2V0V2luZG93U2l6ZSgpO1xuICAgIGNvbnN0IHJlY3QgPSBzZWxmLmltYWdlLiRjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY29udEggPSByZWN0LmhlaWdodDtcbiAgICBjb25zdCB7XG4gICAgICBzcGVlZFxuICAgIH0gPSBzZWxmLm9wdGlvbnM7XG4gICAgY29uc3QgaXNTY3JvbGwgPSBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3Njcm9sbCcgfHwgc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY3JvbGwtb3BhY2l0eSc7XG4gICAgbGV0IHNjcm9sbERpc3QgPSAwO1xuICAgIGxldCByZXN1bHRIID0gY29udEg7XG4gICAgbGV0IHJlc3VsdE1UID0gMDtcblxuICAgIC8vIHNjcm9sbCBwYXJhbGxheFxuICAgIGlmIChpc1Njcm9sbCkge1xuICAgICAgLy8gc2Nyb2xsIGRpc3RhbmNlIGFuZCBoZWlnaHQgZm9yIGltYWdlXG4gICAgICBpZiAoc3BlZWQgPCAwKSB7XG4gICAgICAgIHNjcm9sbERpc3QgPSBzcGVlZCAqIE1hdGgubWF4KGNvbnRILCB3bmRIKTtcbiAgICAgICAgaWYgKHduZEggPCBjb250SCkge1xuICAgICAgICAgIHNjcm9sbERpc3QgLT0gc3BlZWQgKiAoY29udEggLSB3bmRIKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsRGlzdCA9IHNwZWVkICogKGNvbnRIICsgd25kSCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNpemUgZm9yIHNjcm9sbCBwYXJhbGxheFxuICAgICAgaWYgKHNwZWVkID4gMSkge1xuICAgICAgICByZXN1bHRIID0gTWF0aC5hYnMoc2Nyb2xsRGlzdCAtIHduZEgpO1xuICAgICAgfSBlbHNlIGlmIChzcGVlZCA8IDApIHtcbiAgICAgICAgcmVzdWx0SCA9IHNjcm9sbERpc3QgLyBzcGVlZCArIE1hdGguYWJzKHNjcm9sbERpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0SCArPSAod25kSCAtIGNvbnRIKSAqICgxIC0gc3BlZWQpO1xuICAgICAgfVxuICAgICAgc2Nyb2xsRGlzdCAvPSAyO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIHNjcm9sbCBkaXN0YW5jZVxuICAgIHNlbGYucGFyYWxsYXhTY3JvbGxEaXN0YW5jZSA9IHNjcm9sbERpc3Q7XG5cbiAgICAvLyB2ZXJ0aWNhbCBjZW50ZXJcbiAgICBpZiAoaXNTY3JvbGwpIHtcbiAgICAgIHJlc3VsdE1UID0gKHduZEggLSByZXN1bHRIKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdE1UID0gKGNvbnRIIC0gcmVzdWx0SCkgLyAyO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHJlc3VsdCB0byBpdGVtXG4gICAgc2VsZi5jc3Moc2VsZi5pbWFnZS4kaXRlbSwge1xuICAgICAgaGVpZ2h0OiBgJHtyZXN1bHRIfXB4YCxcbiAgICAgIG1hcmdpblRvcDogYCR7cmVzdWx0TVR9cHhgLFxuICAgICAgbGVmdDogc2VsZi5pbWFnZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyA/IGAke3JlY3QubGVmdH1weGAgOiAnMCcsXG4gICAgICB3aWR0aDogYCR7cmVjdC53aWR0aH1weGBcbiAgICB9KTtcblxuICAgIC8vIGNhbGwgb25Db3ZlckltYWdlIGV2ZW50XG4gICAgaWYgKHNlbGYub3B0aW9ucy5vbkNvdmVySW1hZ2UpIHtcbiAgICAgIHNlbGYub3B0aW9ucy5vbkNvdmVySW1hZ2UuY2FsbChzZWxmKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gc29tZSB1c2VmdWwgZGF0YS4gVXNlZCBpbiB0aGUgdmlkZW8gY292ZXIgZnVuY3Rpb25cbiAgICByZXR1cm4ge1xuICAgICAgaW1hZ2U6IHtcbiAgICAgICAgaGVpZ2h0OiByZXN1bHRILFxuICAgICAgICBtYXJnaW5Ub3A6IHJlc3VsdE1UXG4gICAgICB9LFxuICAgICAgY29udGFpbmVyOiByZWN0XG4gICAgfTtcbiAgfVxuICBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbGVtZW50SW5WaWV3cG9ydCB8fCBmYWxzZTtcbiAgfVxuICBvblNjcm9sbChmb3JjZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gc3RvcCBjYWxjdWxhdGlvbnMgaWYgaXRlbSBpcyBub3QgaW4gdmlld3BvcnRcbiAgICBpZiAoIWZvcmNlICYmICFzZWxmLmlzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodDogd25kSFxuICAgIH0gPSBnZXRXaW5kb3dTaXplKCk7XG4gICAgY29uc3QgcmVjdCA9IHNlbGYuJGl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY29udFQgPSByZWN0LnRvcDtcbiAgICBjb25zdCBjb250SCA9IHJlY3QuaGVpZ2h0O1xuICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xuXG4gICAgLy8gY2FsY3VsYXRlIHBhcmFsbGF4IGhlbHBpbmcgdmFyaWFibGVzXG4gICAgY29uc3QgYmVmb3JlVG9wID0gTWF0aC5tYXgoMCwgY29udFQpO1xuICAgIGNvbnN0IGJlZm9yZVRvcEVuZCA9IE1hdGgubWF4KDAsIGNvbnRIICsgY29udFQpO1xuICAgIGNvbnN0IGFmdGVyVG9wID0gTWF0aC5tYXgoMCwgLWNvbnRUKTtcbiAgICBjb25zdCBiZWZvcmVCb3R0b20gPSBNYXRoLm1heCgwLCBjb250VCArIGNvbnRIIC0gd25kSCk7XG4gICAgY29uc3QgYmVmb3JlQm90dG9tRW5kID0gTWF0aC5tYXgoMCwgY29udEggLSAoY29udFQgKyBjb250SCAtIHduZEgpKTtcbiAgICBjb25zdCBhZnRlckJvdHRvbSA9IE1hdGgubWF4KDAsIC1jb250VCArIHduZEggLSBjb250SCk7XG4gICAgY29uc3QgZnJvbVZpZXdwb3J0Q2VudGVyID0gMSAtIDIgKiAoKHduZEggLSBjb250VCkgLyAod25kSCArIGNvbnRIKSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgb24gaG93IHBlcmNlbnQgb2Ygc2VjdGlvbiBpcyB2aXNpYmxlXG4gICAgbGV0IHZpc2libGVQZXJjZW50ID0gMTtcbiAgICBpZiAoY29udEggPCB3bmRIKSB7XG4gICAgICB2aXNpYmxlUGVyY2VudCA9IDEgLSAoYWZ0ZXJUb3AgfHwgYmVmb3JlQm90dG9tKSAvIGNvbnRIO1xuICAgIH0gZWxzZSBpZiAoYmVmb3JlVG9wRW5kIDw9IHduZEgpIHtcbiAgICAgIHZpc2libGVQZXJjZW50ID0gYmVmb3JlVG9wRW5kIC8gd25kSDtcbiAgICB9IGVsc2UgaWYgKGJlZm9yZUJvdHRvbUVuZCA8PSB3bmRIKSB7XG4gICAgICB2aXNpYmxlUGVyY2VudCA9IGJlZm9yZUJvdHRvbUVuZCAvIHduZEg7XG4gICAgfVxuXG4gICAgLy8gb3BhY2l0eVxuICAgIGlmIChzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ29wYWNpdHknIHx8IHNlbGYub3B0aW9ucy50eXBlID09PSAnc2NhbGUtb3BhY2l0eScgfHwgc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY3JvbGwtb3BhY2l0eScpIHtcbiAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAgIHN0eWxlcy5vcGFjaXR5ID0gdmlzaWJsZVBlcmNlbnQ7XG4gICAgfVxuXG4gICAgLy8gc2NhbGVcbiAgICBpZiAoc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY2FsZScgfHwgc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY2FsZS1vcGFjaXR5Jykge1xuICAgICAgbGV0IHNjYWxlID0gMTtcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuc3BlZWQgPCAwKSB7XG4gICAgICAgIHNjYWxlIC09IHNlbGYub3B0aW9ucy5zcGVlZCAqIHZpc2libGVQZXJjZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGUgKz0gc2VsZi5vcHRpb25zLnNwZWVkICogKDEgLSB2aXNpYmxlUGVyY2VudCk7XG4gICAgICB9XG4gICAgICBzdHlsZXMudHJhbnNmb3JtID0gYHNjYWxlKCR7c2NhbGV9KSB0cmFuc2xhdGUzZCgwLDAsMClgO1xuICAgIH1cblxuICAgIC8vIHNjcm9sbFxuICAgIGlmIChzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3Njcm9sbCcgfHwgc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY3JvbGwtb3BhY2l0eScpIHtcbiAgICAgIGxldCBwb3NpdGlvblkgPSBzZWxmLnBhcmFsbGF4U2Nyb2xsRGlzdGFuY2UgKiBmcm9tVmlld3BvcnRDZW50ZXI7XG5cbiAgICAgIC8vIGZpeCBpZiBwYXJhbGxheCBibG9jayBpbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAgaWYgKHNlbGYuaW1hZ2UucG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgcG9zaXRpb25ZIC09IGNvbnRUO1xuICAgICAgfVxuICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCR7cG9zaXRpb25ZfXB4LDApYDtcbiAgICB9XG4gICAgc2VsZi5jc3Moc2VsZi5pbWFnZS4kaXRlbSwgc3R5bGVzKTtcblxuICAgIC8vIGNhbGwgb25TY3JvbGwgZXZlbnRcbiAgICBpZiAoc2VsZi5vcHRpb25zLm9uU2Nyb2xsKSB7XG4gICAgICBzZWxmLm9wdGlvbnMub25TY3JvbGwuY2FsbChzZWxmLCB7XG4gICAgICAgIHNlY3Rpb246IHJlY3QsXG4gICAgICAgIGJlZm9yZVRvcCxcbiAgICAgICAgYmVmb3JlVG9wRW5kLFxuICAgICAgICBhZnRlclRvcCxcbiAgICAgICAgYmVmb3JlQm90dG9tLFxuICAgICAgICBiZWZvcmVCb3R0b21FbmQsXG4gICAgICAgIGFmdGVyQm90dG9tLFxuICAgICAgICB2aXNpYmxlUGVyY2VudCxcbiAgICAgICAgZnJvbVZpZXdwb3J0Q2VudGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25SZXNpemUoKSB7XG4gICAgdGhpcy5jb3ZlckltYWdlKCk7XG4gIH1cbn1cblxuLy8gZ2xvYmFsIGRlZmluaXRpb25cbmNvbnN0IGphcmFsbGF4JDEgPSBmdW5jdGlvbiAoaXRlbXMsIG9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgLy8gY2hlY2sgZm9yIGRvbSBlbGVtZW50XG4gIC8vIHRoYW5rczogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODQyODYvamF2YXNjcmlwdC1pc2RvbS1ob3ctZG8teW91LWNoZWNrLWlmLWEtamF2YXNjcmlwdC1vYmplY3QtaXMtYS1kb20tb2JqZWN0XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnID8gaXRlbXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IGl0ZW1zICYmIHR5cGVvZiBpdGVtcyA9PT0gJ29iamVjdCcgJiYgaXRlbXMgIT09IG51bGwgJiYgaXRlbXMubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIGl0ZW1zLm5vZGVOYW1lID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW1zID0gW2l0ZW1zXTtcbiAgfVxuICBjb25zdCBsZW4gPSBpdGVtcy5sZW5ndGg7XG4gIGxldCBrID0gMDtcbiAgbGV0IHJldDtcbiAgZm9yIChrOyBrIDwgbGVuOyBrICs9IDEpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKCFpdGVtc1trXS5qYXJhbGxheCkge1xuICAgICAgICBpdGVtc1trXS5qYXJhbGxheCA9IG5ldyBKYXJhbGxheChpdGVtc1trXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpdGVtc1trXS5qYXJhbGxheCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgIHJldCA9IGl0ZW1zW2tdLmphcmFsbGF4W29wdGlvbnNdLmFwcGx5KGl0ZW1zW2tdLmphcmFsbGF4LCBhcmdzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbXM7XG59O1xuamFyYWxsYXgkMS5jb25zdHJ1Y3RvciA9IEphcmFsbGF4O1xuXG4vKiFcbiAqIFZpZGVvIFdvcmtlciB2Mi4yLjAgKGh0dHBzOi8vZ2l0aHViLmNvbS9uay1vL3ZpZGVvLXdvcmtlcilcbiAqIENvcHlyaWdodCAyMDI0IG5LIDxodHRwczovL25rZGV2LmluZm8+XG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9uay1vL3ZpZGVvLXdvcmtlci9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYXV0b3BsYXk6IGZhbHNlLFxuICBsb29wOiBmYWxzZSxcbiAgbXV0ZTogZmFsc2UsXG4gIHZvbHVtZTogMTAwLFxuICBzaG93Q29udHJvbHM6IHRydWUsXG4gIGFjY2Vzc2liaWxpdHlIaWRkZW46IGZhbHNlLFxuICAvLyBzdGFydCAvIGVuZCB2aWRlbyB0aW1lIGluIHNlY29uZHNcbiAgc3RhcnRUaW1lOiAwLFxuICBlbmRUaW1lOiAwXG59O1xuXG4vKipcbiAqIEV4dGVuZCBsaWtlIGpRdWVyeS5leHRlbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3V0IC0gb3V0cHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uYW55fSBhcmdzIC0gYWRkaXRpb25hbCBvYmplY3RzIHRvIGV4dGVuZC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBleHRlbmQob3V0LCAuLi5hcmdzKSB7XG4gIG91dCA9IG91dCB8fCB7fTtcbiAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChpID0+IHtcbiAgICBpZiAoIWFyZ3NbaV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoYXJnc1tpXSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgb3V0W2tleV0gPSBhcmdzW2ldW2tleV07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufVxubGV0IElEID0gMDtcbmNsYXNzIFZpZGVvV29ya2VyQmFzZSB7XG4gIHR5cGUgPSAnbm9uZSc7XG4gIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudXJsID0gdXJsO1xuICAgIHNlbGYub3B0aW9uc19kZWZhdWx0ID0ge1xuICAgICAgLi4uZGVmYXVsdHNcbiAgICB9O1xuICAgIHNlbGYub3B0aW9ucyA9IGV4dGVuZCh7fSwgc2VsZi5vcHRpb25zX2RlZmF1bHQsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgVVJMXG4gICAgc2VsZi52aWRlb0lEID0gc2VsZi5jb25zdHJ1Y3Rvci5wYXJzZVVSTCh1cmwpO1xuXG4gICAgLy8gaW5pdFxuICAgIGlmIChzZWxmLnZpZGVvSUQpIHtcbiAgICAgIHNlbGYuaW5pdCgpO1xuICAgIH1cbiAgfVxuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMudmlkZW9JRDtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuSUQgPSBJRDtcbiAgICBJRCArPSAxO1xuICAgIHNlbGYucGxheWVySUQgPSBgVmlkZW9Xb3JrZXItJHtzZWxmLklEfWA7XG4gIH1cblxuICAvLyBldmVudHNcbiAgb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVzZXJFdmVudHNMaXN0ID0gdGhpcy51c2VyRXZlbnRzTGlzdCB8fCBbXTtcblxuICAgIC8vIGFkZCBuZXcgY2FsbGJhY2sgaW4gZXZlbnRzIGxpc3RcbiAgICAodGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXSB8fCAodGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXSA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gIH1cbiAgb2ZmKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnVzZXJFdmVudHNMaXN0IHx8ICF0aGlzLnVzZXJFdmVudHNMaXN0W25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnVzZXJFdmVudHNMaXN0W25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVzZXJFdmVudHNMaXN0W25hbWVdLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgICAgIGlmICh2YWwgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXVtrZXldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmaXJlKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy51c2VyRXZlbnRzTGlzdCAmJiB0eXBlb2YgdGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudXNlckV2ZW50c0xpc3RbbmFtZV0uZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgICAvLyBjYWxsIHdpdGggYWxsIGFyZ3VtZW50c1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgdmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kcyB1c2VkIGluIHByb3ZpZGVycy5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIHN0YXRpYyBwYXJzZVVSTCh1cmwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcGxheShzdGFydCkge31cbiAgcGF1c2UoKSB7fVxuICBtdXRlKCkge31cbiAgdW5tdXRlKCkge31cbiAgc2V0Vm9sdW1lKHZvbHVtZSA9IGZhbHNlKSB7fVxuICBnZXRWb2x1bWUoY2FsbGJhY2spIHt9XG4gIGdldE11dGVkKGNhbGxiYWNrKSB7fVxuICBzZXRDdXJyZW50VGltZShjdXJyZW50VGltZSA9IGZhbHNlKSB7fVxuICBnZXRDdXJyZW50VGltZShjYWxsYmFjaykge31cbiAgZ2V0SW1hZ2VVUkwoY2FsbGJhY2spIHt9XG4gIGdldFZpZGVvKGNhbGxiYWNrKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlICovXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xubGV0IHdpbjtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW4gPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbiA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbiA9IHNlbGY7XG59IGVsc2Uge1xuICB3aW4gPSB7fTtcbn1cbnZhciBnbG9iYWwkMSA9IHdpbjtcblxuLy8gRGVmZXJyZWRcbi8vIHRoYW5rcyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MDk2NzE1L2ltcGxlbWVudC1kZWZlcnJlZC1vYmplY3Qtd2l0aG91dC11c2luZy1qcXVlcnlcbmZ1bmN0aW9uIERlZmVycmVkKCkge1xuICB0aGlzLmRvbmVDYWxsYmFja3MgPSBbXTtcbiAgdGhpcy5mYWlsQ2FsbGJhY2tzID0gW107XG59XG5EZWZlcnJlZC5wcm90b3R5cGUgPSB7XG4gIGV4ZWN1dGUobGlzdCwgYXJncykge1xuICAgIGxldCBpID0gbGlzdC5sZW5ndGg7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgIHdoaWxlIChpKSB7XG4gICAgICBpIC09IDE7XG4gICAgICBsaXN0W2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgcmVzb2x2ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5leGVjdXRlKHRoaXMuZG9uZUNhbGxiYWNrcywgYXJncyk7XG4gIH0sXG4gIHJlamVjdCguLi5hcmdzKSB7XG4gICAgdGhpcy5leGVjdXRlKHRoaXMuZmFpbENhbGxiYWNrcywgYXJncyk7XG4gIH0sXG4gIGRvbmUoY2FsbGJhY2spIHtcbiAgICB0aGlzLmRvbmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH0sXG4gIGZhaWwoY2FsbGJhY2spIHtcbiAgICB0aGlzLmZhaWxDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH1cbn07XG5sZXQgWW91dHViZUFQSWFkZGVkID0gMDtcbmxldCBsb2FkaW5nWW91dHViZVBsYXllciA9IDA7XG5jb25zdCBsb2FkaW5nWW91dHViZURlZmVyID0gLyojX19QVVJFX18qL25ldyBEZWZlcnJlZCgpO1xuZnVuY3Rpb24gbG9hZEFQSSQxKCkge1xuICBpZiAoWW91dHViZUFQSWFkZGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFlvdXR1YmVBUElhZGRlZCA9IHRydWU7XG4gIGNvbnN0IHNyYyA9ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS9pZnJhbWVfYXBpJztcblxuICAvLyBhZGQgc2NyaXB0IGluIGhlYWQgc2VjdGlvblxuICBsZXQgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIGxldCBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdGFnLnNyYyA9IHNyYztcbiAgaGVhZC5hcHBlbmRDaGlsZCh0YWcpO1xuICBoZWFkID0gbnVsbDtcbiAgdGFnID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG9uQVBJcmVhZHkkMShjYWxsYmFjaykge1xuICAvLyBMaXN0ZW4gZm9yIGdsb2JhbCBZVCBwbGF5ZXIgY2FsbGJhY2tcbiAgaWYgKCh0eXBlb2YgZ2xvYmFsJDEuWVQgPT09ICd1bmRlZmluZWQnIHx8IGdsb2JhbCQxLllULmxvYWRlZCA9PT0gMCkgJiYgIWxvYWRpbmdZb3V0dWJlUGxheWVyKSB7XG4gICAgLy8gUHJldmVudHMgUmVhZHkgZXZlbnQgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2VcbiAgICBsb2FkaW5nWW91dHViZVBsYXllciA9IDE7XG5cbiAgICAvLyBDcmVhdGVzIGRlZmVycmVkIHNvLCBvdGhlciBwbGF5ZXJzIGtub3cgd2hlbiB0byB3YWl0LlxuICAgIGdsb2JhbCQxLm9uWW91VHViZUlmcmFtZUFQSVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ2xvYmFsJDEub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkgPSBudWxsO1xuICAgICAgbG9hZGluZ1lvdXR1YmVEZWZlci5yZXNvbHZlKCdkb25lJyk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCQxLllUID09PSAnb2JqZWN0JyAmJiBnbG9iYWwkMS5ZVC5sb2FkZWQgPT09IDEpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIGxvYWRpbmdZb3V0dWJlRGVmZXIuZG9uZSgoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBWaWRlb1dvcmtlcllvdXR1YmUgZXh0ZW5kcyBWaWRlb1dvcmtlckJhc2Uge1xuICB0eXBlID0gJ3lvdXR1YmUnO1xuICBzdGF0aWMgcGFyc2VVUkwodXJsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgY29uc3QgcmVnRXhwID0gLy4qKD86eW91dHUuYmVcXC98dlxcL3x1XFwvXFx3XFwvfGVtYmVkXFwvfHNob3J0c1xcL3x3YXRjaFxcP3Y9KShbXiNcXCZcXD9dKikuKi87XG4gICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVnRXhwKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0ubGVuZ3RoID09PSAxMSA/IG1hdGNoWzFdIDogZmFsc2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG4gICAgbG9hZEFQSSQxKCk7XG4gIH1cbiAgcGxheShzdGFydCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgIXNlbGYucGxheWVyLnBsYXlWaWRlbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2VsZi5wbGF5ZXIuc2Vla1RvKHN0YXJ0IHx8IDApO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsJDEuWVQuUGxheWVyU3RhdGUuUExBWUlORyAhPT0gc2VsZi5wbGF5ZXIuZ2V0UGxheWVyU3RhdGUoKSkge1xuICAgICAgLy8gRG9uJ3QgcGxheSBpZiB2aWRlbyBpcyBhbHJlYWR5IGVuZGVkIGFuZCB3aXRoIG5vIGxvb3AuXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmVuZFRpbWUgJiYgIXNlbGYub3B0aW9ucy5sb29wKSB7XG4gICAgICAgIHNlbGYuZ2V0Q3VycmVudFRpbWUoc2Vjb25kcyA9PiB7XG4gICAgICAgICAgaWYgKHNlY29uZHMgPCBzZWxmLm9wdGlvbnMuZW5kVGltZSkge1xuICAgICAgICAgICAgc2VsZi5wbGF5ZXIucGxheVZpZGVvKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucGxheWVyLnBsYXlWaWRlbygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXVzZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyIHx8ICFzZWxmLnBsYXllci5wYXVzZVZpZGVvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChnbG9iYWwkMS5ZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HID09PSBzZWxmLnBsYXllci5nZXRQbGF5ZXJTdGF0ZSgpKSB7XG4gICAgICBzZWxmLnBsYXllci5wYXVzZVZpZGVvKCk7XG4gICAgfVxuICB9XG4gIG11dGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCAhc2VsZi5wbGF5ZXIubXV0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci5tdXRlKCk7XG4gIH1cbiAgdW5tdXRlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgIXNlbGYucGxheWVyLnVuTXV0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci51bk11dGUoKTtcbiAgfVxuICBzZXRWb2x1bWUodm9sdW1lID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyIHx8IHR5cGVvZiB2b2x1bWUgIT09ICdudW1iZXInIHx8ICFzZWxmLnBsYXllci5zZXRWb2x1bWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5wbGF5ZXIuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gIH1cbiAgZ2V0Vm9sdW1lKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZi5wbGF5ZXIuZ2V0Vm9sdW1lKSB7XG4gICAgICBjYWxsYmFjayhzZWxmLnBsYXllci5nZXRWb2x1bWUoKSk7XG4gICAgfVxuICB9XG4gIGdldE11dGVkKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZWxmLnBsYXllci5pc011dGVkKSB7XG4gICAgICBjYWxsYmFjayhzZWxmLnBsYXllci5pc011dGVkKCkpO1xuICAgIH1cbiAgfVxuICBzZXRDdXJyZW50VGltZShjdXJyZW50VGltZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCB0eXBlb2YgY3VycmVudFRpbWUgIT09ICdudW1iZXInIHx8ICFzZWxmLnBsYXllci5zZWVrVG8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5wbGF5ZXIuc2Vla1RvKGN1cnJlbnRUaW1lKTtcbiAgfVxuICBnZXRDdXJyZW50VGltZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgIXNlbGYucGxheWVyLmdldEN1cnJlbnRUaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKHNlbGYucGxheWVyLmdldEN1cnJlbnRUaW1lKCkpO1xuICB9XG4gIGdldEltYWdlVVJMKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYudmlkZW9JbWFnZSkge1xuICAgICAgY2FsbGJhY2soc2VsZi52aWRlb0ltYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXZhaWxhYmxlU2l6ZXMgPSBbJ21heHJlc2RlZmF1bHQnLCAnc2RkZWZhdWx0JywgJ2hxZGVmYXVsdCcsICcwJ107XG4gICAgbGV0IHN0ZXAgPSAwO1xuICAgIGNvbnN0IHRlbXBJbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICB0ZW1wSW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGlmIG5vIHRodW1ibmFpbCwgeW91dHViZSBhZGQgdGhlaXIgb3duIGltYWdlIHdpdGggd2lkdGggPSAxMjBweFxuICAgICAgaWYgKCh0aGlzLm5hdHVyYWxXaWR0aCB8fCB0aGlzLndpZHRoKSAhPT0gMTIwIHx8IHN0ZXAgPT09IGF2YWlsYWJsZVNpemVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gb2tcbiAgICAgICAgc2VsZi52aWRlb0ltYWdlID0gYGh0dHBzOi8vaW1nLnlvdXR1YmUuY29tL3ZpLyR7c2VsZi52aWRlb0lEfS8ke2F2YWlsYWJsZVNpemVzW3N0ZXBdfS5qcGdgO1xuICAgICAgICBjYWxsYmFjayhzZWxmLnZpZGVvSW1hZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdHJ5IGFub3RoZXIgc2l6ZVxuICAgICAgICBzdGVwICs9IDE7XG4gICAgICAgIHRoaXMuc3JjID0gYGh0dHBzOi8vaW1nLnlvdXR1YmUuY29tL3ZpLyR7c2VsZi52aWRlb0lEfS8ke2F2YWlsYWJsZVNpemVzW3N0ZXBdfS5qcGdgO1xuICAgICAgfVxuICAgIH07XG4gICAgdGVtcEltZy5zcmMgPSBgaHR0cHM6Ly9pbWcueW91dHViZS5jb20vdmkvJHtzZWxmLnZpZGVvSUR9LyR7YXZhaWxhYmxlU2l6ZXNbc3RlcF19LmpwZ2A7XG4gIH1cbiAgZ2V0VmlkZW8oY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIHJldHVybiBnZW5lcmF0ZWQgdmlkZW8gYmxvY2tcbiAgICBpZiAoc2VsZi4kdmlkZW8pIHtcbiAgICAgIGNhbGxiYWNrKHNlbGYuJHZpZGVvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBnZW5lcmF0ZSBuZXcgdmlkZW8gYmxvY2tcbiAgICBvbkFQSXJlYWR5JDEoKCkgPT4ge1xuICAgICAgbGV0IGhpZGRlbkRpdjtcbiAgICAgIGlmICghc2VsZi4kdmlkZW8pIHtcbiAgICAgICAgaGlkZGVuRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGhpZGRlbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAvLyBHRFBSIENvbXBsaWFuY2UuXG4gICAgICAgIGhvc3Q6ICdodHRwczovL3d3dy55b3V0dWJlLW5vY29va2llLmNvbScsXG4gICAgICAgIHZpZGVvSWQ6IHNlbGYudmlkZW9JRCxcbiAgICAgICAgcGxheWVyVmFyczoge1xuICAgICAgICAgIGF1dG9oaWRlOiAxLFxuICAgICAgICAgIHJlbDogMCxcbiAgICAgICAgICBhdXRvcGxheTogMCxcbiAgICAgICAgICAvLyBhdXRvcGxheSBlbmFibGUgb24gbW9iaWxlIGRldmljZXNcbiAgICAgICAgICBwbGF5c2lubGluZTogMVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBoaWRlIGNvbnRyb2xzXG4gICAgICBpZiAoIXNlbGYub3B0aW9ucy5zaG93Q29udHJvbHMpIHtcbiAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLnBsYXllclZhcnMuaXZfbG9hZF9wb2xpY3kgPSAzO1xuICAgICAgICBzZWxmLnBsYXllck9wdGlvbnMucGxheWVyVmFycy5tb2Rlc3RicmFuZGluZyA9IDE7XG4gICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5wbGF5ZXJWYXJzLmNvbnRyb2xzID0gMDtcbiAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLnBsYXllclZhcnMuc2hvd2luZm8gPSAwO1xuICAgICAgICBzZWxmLnBsYXllck9wdGlvbnMucGxheWVyVmFycy5kaXNhYmxla2IgPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBldmVudHNcbiAgICAgIGxldCB5dFN0YXJ0ZWQ7XG4gICAgICBsZXQgeXRQcm9ncmVzc0ludGVydmFsO1xuICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLmV2ZW50cyA9IHtcbiAgICAgICAgb25SZWFkeShlKSB7XG4gICAgICAgICAgLy8gbXV0ZVxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubXV0ZSkge1xuICAgICAgICAgICAgZS50YXJnZXQubXV0ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYub3B0aW9ucy52b2x1bWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5zZXRWb2x1bWUoc2VsZi5vcHRpb25zLnZvbHVtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYXV0b3BsYXlcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmF1dG9wbGF5KSB7XG4gICAgICAgICAgICBzZWxmLnBsYXkoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuZmlyZSgncmVhZHknLCBlKTtcblxuICAgICAgICAgIC8vIEZvciBzZWFtbGVzcyBsb29wcywgc2V0IHRoZSBlbmRUaW1lIHRvIDAuMSBzZWNvbmRzIGxlc3MgdGhhbiB0aGUgdmlkZW8ncyBkdXJhdGlvblxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uay1vL3ZpZGVvLXdvcmtlci9pc3N1ZXMvMlxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCAmJiAhc2VsZi5vcHRpb25zLmVuZFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZHNPZmZzZXQgPSAwLjE7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMuZW5kVGltZSA9IHNlbGYucGxheWVyLmdldER1cmF0aW9uKCkgLSBzZWNvbmRzT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHZvbHVtZWNoYW5nZVxuICAgICAgICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHNlbGYuZ2V0Vm9sdW1lKHZvbHVtZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMudm9sdW1lICE9PSB2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMudm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgndm9sdW1lY2hhbmdlJywgZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RhdGVDaGFuZ2UoZSkge1xuICAgICAgICAgIC8vIGxvb3BcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmxvb3AgJiYgZS5kYXRhID09PSBnbG9iYWwkMS5ZVC5QbGF5ZXJTdGF0ZS5FTkRFRCkge1xuICAgICAgICAgICAgc2VsZi5wbGF5KHNlbGYub3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXl0U3RhcnRlZCAmJiBlLmRhdGEgPT09IGdsb2JhbCQxLllULlBsYXllclN0YXRlLlBMQVlJTkcpIHtcbiAgICAgICAgICAgIHl0U3RhcnRlZCA9IDE7XG4gICAgICAgICAgICBzZWxmLmZpcmUoJ3N0YXJ0ZWQnLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUuZGF0YSA9PT0gZ2xvYmFsJDEuWVQuUGxheWVyU3RhdGUuUExBWUlORykge1xuICAgICAgICAgICAgc2VsZi5maXJlKCdwbGF5JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlLmRhdGEgPT09IGdsb2JhbCQxLllULlBsYXllclN0YXRlLlBBVVNFRCkge1xuICAgICAgICAgICAgc2VsZi5maXJlKCdwYXVzZScsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZS5kYXRhID09PSBnbG9iYWwkMS5ZVC5QbGF5ZXJTdGF0ZS5FTkRFRCkge1xuICAgICAgICAgICAgc2VsZi5maXJlKCdlbmRlZCcsIGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHByb2dyZXNzIGNoZWNrXG4gICAgICAgICAgaWYgKGUuZGF0YSA9PT0gZ2xvYmFsJDEuWVQuUGxheWVyU3RhdGUuUExBWUlORykge1xuICAgICAgICAgICAgeXRQcm9ncmVzc0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICBzZWxmLmZpcmUoJ3RpbWV1cGRhdGUnLCBlKTtcblxuICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZW5kIG9mIHZpZGVvIGFuZCBwbGF5IGFnYWluIG9yIHN0b3BcbiAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmRUaW1lICYmIHNlbGYucGxheWVyLmdldEN1cnJlbnRUaW1lKCkgPj0gc2VsZi5vcHRpb25zLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYucGxheShzZWxmLm9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh5dFByb2dyZXNzSW50ZXJ2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcihlKSB7XG4gICAgICAgICAgc2VsZi5maXJlKCdlcnJvcicsIGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZmlyc3RJbml0ID0gIXNlbGYuJHZpZGVvO1xuICAgICAgaWYgKGZpcnN0SW5pdCkge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnaWQnLCBzZWxmLnBsYXllcklEKTtcbiAgICAgICAgaGlkZGVuRGl2LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGlkZGVuRGl2KTtcbiAgICAgIH1cbiAgICAgIHNlbGYucGxheWVyID0gc2VsZi5wbGF5ZXIgfHwgbmV3IGdsb2JhbCQxLllULlBsYXllcihzZWxmLnBsYXllcklELCBzZWxmLnBsYXllck9wdGlvbnMpO1xuICAgICAgaWYgKGZpcnN0SW5pdCkge1xuICAgICAgICBzZWxmLiR2aWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYucGxheWVySUQpO1xuXG4gICAgICAgIC8vIGFkZCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hY2Nlc3NpYmlsaXR5SGlkZGVuKSB7XG4gICAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHZpZGVvIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgc2VsZi52aWRlb1dpZHRoID0gcGFyc2VJbnQoc2VsZi4kdmlkZW8uZ2V0QXR0cmlidXRlKCd3aWR0aCcpLCAxMCkgfHwgMTI4MDtcbiAgICAgICAgc2VsZi52aWRlb0hlaWdodCA9IHBhcnNlSW50KHNlbGYuJHZpZGVvLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksIDEwKSB8fCA3MjA7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhzZWxmLiR2aWRlbyk7XG4gICAgfSk7XG4gIH1cbn1cbmxldCBWaW1lb0FQSWFkZGVkID0gMDtcbmxldCBsb2FkaW5nVmltZW9QbGF5ZXIgPSAwO1xuY29uc3QgbG9hZGluZ1ZpbWVvRGVmZXIgPSAvKiNfX1BVUkVfXyovbmV3IERlZmVycmVkKCk7XG5mdW5jdGlvbiBsb2FkQVBJKCkge1xuICBpZiAoVmltZW9BUElhZGRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBWaW1lb0FQSWFkZGVkID0gdHJ1ZTtcblxuICAvLyBVc2VmdWwgd2hlbiBWaW1lbyBBUEkgYWRkZWQgdXNpbmcgUmVxdWlyZUpTIGh0dHBzOi8vZ2l0aHViLmNvbS9uay1vL3ZpZGVvLXdvcmtlci9wdWxsLzdcbiAgaWYgKHR5cGVvZiBnbG9iYWwkMS5WaW1lbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3JjID0gJ2h0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS9hcGkvcGxheWVyLmpzJztcblxuICAvLyBhZGQgc2NyaXB0IGluIGhlYWQgc2VjdGlvblxuICBsZXQgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIGxldCBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdGFnLnNyYyA9IHNyYztcbiAgaGVhZC5hcHBlbmRDaGlsZCh0YWcpO1xuICBoZWFkID0gbnVsbDtcbiAgdGFnID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG9uQVBJcmVhZHkoY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWwkMS5WaW1lbyA9PT0gJ3VuZGVmaW5lZCcgJiYgIWxvYWRpbmdWaW1lb1BsYXllcikge1xuICAgIGxvYWRpbmdWaW1lb1BsYXllciA9IDE7XG4gICAgY29uc3QgdmltZW9JbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuVmltZW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodmltZW9JbnRlcnZhbCk7XG4gICAgICAgIGxvYWRpbmdWaW1lb0RlZmVyLnJlc29sdmUoJ2RvbmUnKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LCAyMCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCQxLlZpbWVvICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZWxzZSB7XG4gICAgbG9hZGluZ1ZpbWVvRGVmZXIuZG9uZSgoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBWaWRlb1dvcmtlclZpbWVvIGV4dGVuZHMgVmlkZW9Xb3JrZXJCYXNlIHtcbiAgdHlwZSA9ICd2aW1lbyc7XG4gIHN0YXRpYyBwYXJzZVVSTCh1cmwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICBjb25zdCByZWdFeHAgPSAvaHR0cHM/OlxcL1xcLyg/Ond3d1xcLnxwbGF5ZXJcXC4pP3ZpbWVvLmNvbVxcLyg/OmNoYW5uZWxzXFwvKD86XFx3K1xcLyk/fGdyb3Vwc1xcLyhbXi9dKilcXC92aWRlb3NcXC98YWxidW1cXC8oXFxkKylcXC92aWRlb1xcL3x2aWRlb1xcL3wpKFxcZCspKD86JHxcXC98XFw/KS87XG4gICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVnRXhwKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbM10gPyBtYXRjaFszXSA6IGZhbHNlO1xuICB9XG5cbiAgLy8gVHJ5IHRvIGV4dHJhY3QgYSBoYXNoIGZvciBwcml2YXRlIHZpZGVvcyBmcm9tIHRoZSBVUkwuXG4gIC8vIFRoYW5rcyB0byBodHRwczovL2dpdGh1Yi5jb20vc2FtcG90dHMvcGx5clxuICBzdGF0aWMgcGFyc2VVUkxIYXNoKHVybCkge1xuICAgIC8qIFRoaXMgcmVnZXggbWF0Y2hlcyBhIGhleGFkZWNpbWFsIGhhc2ggaWYgZ2l2ZW4gaW4gYW55IG9mIHRoZXNlIGZvcm1zOlxuICAgICAqICAtIFtodHRwczovL3BsYXllci5ddmltZW8uY29tL3ZpZGVvL3tpZH0ve2hhc2h9Wz9wYXJhbXNdXG4gICAgICogIC0gW2h0dHBzOi8vcGxheWVyLl12aW1lby5jb20vdmlkZW8ve2lkfT9oPXtoYXNofVsmcGFyYW1zXVxuICAgICAqICAtIFtodHRwczovL3BsYXllci5ddmltZW8uY29tL3ZpZGVvL3tpZH0/W3BhcmFtc10maD17aGFzaH1cbiAgICAgKiAgLSB2aWRlby97aWR9L3toYXNofVxuICAgICAqIElmIG1hdGNoZWQsIHRoZSBoYXNoIGlzIGF2YWlsYWJsZSBpbiBjYXB0dXJlIGdyb3VwIDRcbiAgICAgKi9cbiAgICBjb25zdCByZWdleCA9IC9eLioodmltZW8uY29tXFwvfHZpZGVvXFwvKShcXGQrKShcXD8uKiYqaD18XFwvKSsoW1xcZCxhLWZdKykvO1xuICAgIGNvbnN0IGZvdW5kID0gdXJsLm1hdGNoKHJlZ2V4KTtcbiAgICByZXR1cm4gZm91bmQgJiYgZm91bmQubGVuZ3RoID09PSA1ID8gZm91bmRbNF0gOiBudWxsO1xuICB9XG4gIGluaXQoKSB7XG4gICAgc3VwZXIuaW5pdCgpO1xuICAgIGxvYWRBUEkoKTtcbiAgfVxuICBwbGF5KHN0YXJ0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2VsZi5wbGF5ZXIuc2V0Q3VycmVudFRpbWUoc3RhcnQpO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci5nZXRQYXVzZWQoKS50aGVuKHBhdXNlZCA9PiB7XG4gICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgIC8vIERvbid0IHBsYXkgaWYgdmlkZW8gaXMgYWxyZWFkeSBlbmRlZCBhbmQgd2l0aCBubyBsb29wLlxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuZFRpbWUgJiYgIXNlbGYub3B0aW9ucy5sb29wKSB7XG4gICAgICAgICAgc2VsZi5nZXRDdXJyZW50VGltZShzZWNvbmRzID0+IHtcbiAgICAgICAgICAgIGlmIChzZWNvbmRzIDwgc2VsZi5vcHRpb25zLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYucGxheWVyLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5wbGF5ZXIuZ2V0UGF1c2VkKCkudGhlbihwYXVzZWQgPT4ge1xuICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgc2VsZi5wbGF5ZXIucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgIXNlbGYucGxheWVyLnNldFZvbHVtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnNldFZvbHVtZSgwKTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCAhc2VsZi5wbGF5ZXIuc2V0Vm9sdW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW4gY2FzZSB0aGUgZGVmYXVsdCB2b2x1bWUgaXMgMCwgd2UgaGF2ZSB0byBzZXQgMTAwIHdoZW4gdW5tdXRlLlxuICAgIHNlbGYuc2V0Vm9sdW1lKHNlbGYub3B0aW9ucy52b2x1bWUgfHwgMTAwKTtcbiAgfVxuICBzZXRWb2x1bWUodm9sdW1lID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyIHx8IHR5cGVvZiB2b2x1bWUgIT09ICdudW1iZXInIHx8ICFzZWxmLnBsYXllci5zZXRWb2x1bWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5wbGF5ZXIuc2V0Vm9sdW1lKHZvbHVtZSAvIDEwMCk7XG4gIH1cbiAgZ2V0Vm9sdW1lKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZi5wbGF5ZXIuZ2V0Vm9sdW1lKSB7XG4gICAgICBzZWxmLnBsYXllci5nZXRWb2x1bWUoKS50aGVuKHZvbHVtZSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHZvbHVtZSAqIDEwMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0TXV0ZWQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYucGxheWVyLmdldFZvbHVtZSkge1xuICAgICAgc2VsZi5wbGF5ZXIuZ2V0Vm9sdW1lKCkudGhlbih2b2x1bWUgPT4ge1xuICAgICAgICBjYWxsYmFjayghIXZvbHVtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc2V0Q3VycmVudFRpbWUoY3VycmVudFRpbWUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgdHlwZW9mIGN1cnJlbnRUaW1lICE9PSAnbnVtYmVyJyB8fCAhc2VsZi5wbGF5ZXIuc2V0Q3VycmVudFRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5wbGF5ZXIuc2V0Q3VycmVudFRpbWUoY3VycmVudFRpbWUpO1xuICB9XG4gIGdldEN1cnJlbnRUaW1lKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCAhc2VsZi5wbGF5ZXIuZ2V0Q3VycmVudFRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5wbGF5ZXIuZ2V0Q3VycmVudFRpbWUoKS50aGVuKGN1cnJlbnRUaW1lID0+IHtcbiAgICAgIGNhbGxiYWNrKGN1cnJlbnRUaW1lKTtcbiAgICB9KTtcbiAgfVxuICBnZXRJbWFnZVVSTChjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLnZpZGVvSW1hZ2UpIHtcbiAgICAgIGNhbGxiYWNrKHNlbGYudmlkZW9JbWFnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2Ugc2hvdWxkIHByb3ZpZGUgd2lkdGggdG8gZ2V0IEhRIHRodW1ibmFpbCBVUkwuXG4gICAgbGV0IHdpZHRoID0gZ2xvYmFsJDEuaW5uZXJXaWR0aCB8fCAxOTIwO1xuICAgIGlmIChnbG9iYWwkMS5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICB3aWR0aCAqPSBnbG9iYWwkMS5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICB3aWR0aCA9IE1hdGgubWluKHdpZHRoLCAxOTIwKTtcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIC8vIGh0dHBzOi8vdmltZW8uY29tL2FwaS9vZW1iZWQuanNvbj91cmw9aHR0cHM6Ly92aW1lby5jb20vMjM1MjEyNTI3XG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBgaHR0cHM6Ly92aW1lby5jb20vYXBpL29lbWJlZC5qc29uP3VybD0ke3NlbGYudXJsfSZ3aWR0aD0ke3dpZHRofWAsIHRydWUpO1xuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgLy8gU3VjY2VzcyFcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIGlmIChyZXNwb25zZS50aHVtYm5haWxfdXJsKSB7XG4gICAgICAgICAgICBzZWxmLnZpZGVvSW1hZ2UgPSByZXNwb25zZS50aHVtYm5haWxfdXJsO1xuICAgICAgICAgICAgY2FsbGJhY2soc2VsZi52aWRlb0ltYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIHJlcXVlc3QgPSBudWxsO1xuICB9XG4gIGdldFZpZGVvKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyByZXR1cm4gZ2VuZXJhdGVkIHZpZGVvIGJsb2NrXG4gICAgaWYgKHNlbGYuJHZpZGVvKSB7XG4gICAgICBjYWxsYmFjayhzZWxmLiR2aWRlbyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgbmV3IHZpZGVvIGJsb2NrXG4gICAgb25BUElyZWFkeSgoKSA9PiB7XG4gICAgICBsZXQgaGlkZGVuRGl2O1xuICAgICAgaWYgKCFzZWxmLiR2aWRlbykge1xuICAgICAgICBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaGlkZGVuRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBzZWxmLnBsYXllck9wdGlvbnMgPSB7XG4gICAgICAgIC8vIEdEUFIgQ29tcGxpYW5jZS5cbiAgICAgICAgZG50OiAxLFxuICAgICAgICBpZDogc2VsZi52aWRlb0lELFxuICAgICAgICBhdXRvcGF1c2U6IDAsXG4gICAgICAgIHRyYW5zcGFyZW50OiAwLFxuICAgICAgICBhdXRvcGxheTogc2VsZi5vcHRpb25zLmF1dG9wbGF5ID8gMSA6IDAsXG4gICAgICAgIGxvb3A6IHNlbGYub3B0aW9ucy5sb29wID8gMSA6IDAsXG4gICAgICAgIG11dGVkOiBzZWxmLm9wdGlvbnMubXV0ZSB8fCBzZWxmLm9wdGlvbnMudm9sdW1lID09PSAwID8gMSA6IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIHByaXZhdGUgdmlkZW8gaGFzaFxuICAgICAgY29uc3QgdXJsSGFzaCA9IHNlbGYuY29uc3RydWN0b3IucGFyc2VVUkxIYXNoKHNlbGYudXJsKTtcbiAgICAgIGlmICh1cmxIYXNoKSB7XG4gICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5oID0gdXJsSGFzaDtcbiAgICAgIH1cblxuICAgICAgLy8gaGlkZSBjb250cm9sc1xuICAgICAgaWYgKCFzZWxmLm9wdGlvbnMuc2hvd0NvbnRyb2xzKSB7XG4gICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5jb250cm9scyA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIGVuYWJsZSBiYWNrZ3JvdW5kIG9wdGlvblxuICAgICAgaWYgKCFzZWxmLm9wdGlvbnMuc2hvd0NvbnRyb2xzICYmIHNlbGYub3B0aW9ucy5sb29wICYmIHNlbGYub3B0aW9ucy5hdXRvcGxheSkge1xuICAgICAgICBzZWxmLnBsYXllck9wdGlvbnMuYmFja2dyb3VuZCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoIXNlbGYuJHZpZGVvKSB7XG4gICAgICAgIGxldCBwbGF5ZXJPcHRpb25zU3RyaW5nID0gJyc7XG4gICAgICAgIE9iamVjdC5rZXlzKHNlbGYucGxheWVyT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGlmIChwbGF5ZXJPcHRpb25zU3RyaW5nICE9PSAnJykge1xuICAgICAgICAgICAgcGxheWVyT3B0aW9uc1N0cmluZyArPSAnJic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBsYXllck9wdGlvbnNTdHJpbmcgKz0gYCR7a2V5fT0ke2VuY29kZVVSSUNvbXBvbmVudChzZWxmLnBsYXllck9wdGlvbnNba2V5XSl9YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2UgbmVlZCB0byBjcmVhdGUgaWZyYW1lIG1hbnVhbGx5IGJlY2F1c2Ugd2hlbiB3ZSBjcmVhdGUgaXQgdXNpbmcgQVBJXG4gICAgICAgIC8vIGpzIGV2ZW50cyB3b24ndCB0cmlnZ2VycyBhZnRlciBpZnJhbWUgbW92ZWQgdG8gYW5vdGhlciBwbGFjZVxuICAgICAgICBzZWxmLiR2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ2lkJywgc2VsZi5wbGF5ZXJJRCk7XG4gICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnc3JjJywgYGh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8ke3NlbGYudmlkZW9JRH0/JHtwbGF5ZXJPcHRpb25zU3RyaW5nfWApO1xuICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ2ZyYW1lYm9yZGVyJywgJzAnKTtcbiAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdtb3phbGxvd2Z1bGxzY3JlZW4nLCAnJyk7XG4gICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnYWxsb3dmdWxsc2NyZWVuJywgJycpO1xuICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ1ZpbWVvIHZpZGVvIHBsYXllcicpO1xuXG4gICAgICAgIC8vIGFkZCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hY2Nlc3NpYmlsaXR5SGlkZGVuKSB7XG4gICAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGRlbkRpdi5hcHBlbmRDaGlsZChzZWxmLiR2aWRlbyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGlkZGVuRGl2KTtcbiAgICAgIH1cbiAgICAgIHNlbGYucGxheWVyID0gc2VsZi5wbGF5ZXIgfHwgbmV3IGdsb2JhbCQxLlZpbWVvLlBsYXllcihzZWxmLiR2aWRlbywgc2VsZi5wbGF5ZXJPcHRpb25zKTtcblxuICAgICAgLy8gU2luY2UgVmltZW8gcmVtb3ZlZCB0aGUgYHZvbHVtZWAgcGFyYW1ldGVyLCB3ZSBoYXZlIHRvIHNldCBpdCBtYW51YWxseS5cbiAgICAgIGlmICghc2VsZi5vcHRpb25zLm11dGUgJiYgdHlwZW9mIHNlbGYub3B0aW9ucy52b2x1bWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuc2V0Vm9sdW1lKHNlbGYub3B0aW9ucy52b2x1bWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgY3VycmVudCB0aW1lIGZvciBhdXRvcGxheVxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5zdGFydFRpbWUgJiYgc2VsZi5vcHRpb25zLmF1dG9wbGF5KSB7XG4gICAgICAgIHNlbGYucGxheWVyLnNldEN1cnJlbnRUaW1lKHNlbGYub3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdmlkZW8gd2lkdGggYW5kIGhlaWdodFxuICAgICAgc2VsZi5wbGF5ZXIuZ2V0VmlkZW9XaWR0aCgpLnRoZW4od2lkdGggPT4ge1xuICAgICAgICBzZWxmLnZpZGVvV2lkdGggPSB3aWR0aCB8fCAxMjgwO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnBsYXllci5nZXRWaWRlb0hlaWdodCgpLnRoZW4oaGVpZ2h0ID0+IHtcbiAgICAgICAgc2VsZi52aWRlb0hlaWdodCA9IGhlaWdodCB8fCA3MjA7XG4gICAgICB9KTtcblxuICAgICAgLy8gZXZlbnRzXG4gICAgICBsZXQgdm1TdGFydGVkO1xuICAgICAgc2VsZi5wbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCBlID0+IHtcbiAgICAgICAgaWYgKCF2bVN0YXJ0ZWQpIHtcbiAgICAgICAgICBzZWxmLmZpcmUoJ3N0YXJ0ZWQnLCBlKTtcbiAgICAgICAgICB2bVN0YXJ0ZWQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZmlyZSgndGltZXVwZGF0ZScsIGUpO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBlbmQgb2YgdmlkZW8gYW5kIHBsYXkgYWdhaW4gb3Igc3RvcFxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuZFRpbWUgJiYgZS5zZWNvbmRzID49IHNlbGYub3B0aW9ucy5lbmRUaW1lKSB7XG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5sb29wKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXkoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucGF1c2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2VsZi5wbGF5ZXIub24oJ3BsYXknLCBlID0+IHtcbiAgICAgICAgc2VsZi5maXJlKCdwbGF5JywgZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBzdGFydCB0aW1lIGFuZCBzdGFydCB3aXRoIGl0XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuc3RhcnRUaW1lICYmIGUuc2Vjb25kcyA9PT0gMCkge1xuICAgICAgICAgIHNlbGYucGxheShzZWxmLm9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxmLnBsYXllci5vbigncGF1c2UnLCBlID0+IHtcbiAgICAgICAgc2VsZi5maXJlKCdwYXVzZScsIGUpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnBsYXllci5vbignZW5kZWQnLCBlID0+IHtcbiAgICAgICAgc2VsZi5maXJlKCdlbmRlZCcsIGUpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnBsYXllci5vbignbG9hZGVkJywgZSA9PiB7XG4gICAgICAgIHNlbGYuZmlyZSgncmVhZHknLCBlKTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5wbGF5ZXIub24oJ3ZvbHVtZWNoYW5nZScsIGUgPT4ge1xuICAgICAgICBzZWxmLmdldFZvbHVtZSh2b2x1bWUgPT4ge1xuICAgICAgICAgIHNlbGYub3B0aW9ucy52b2x1bWUgPSB2b2x1bWU7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLmZpcmUoJ3ZvbHVtZWNoYW5nZScsIGUpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnBsYXllci5vbignZXJyb3InLCBlID0+IHtcbiAgICAgICAgc2VsZi5maXJlKCdlcnJvcicsIGUpO1xuICAgICAgfSk7XG4gICAgICBjYWxsYmFjayhzZWxmLiR2aWRlbyk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFZpZGVvV29ya2VyTG9jYWwgZXh0ZW5kcyBWaWRlb1dvcmtlckJhc2Uge1xuICB0eXBlID0gJ2xvY2FsJztcbiAgc3RhdGljIHBhcnNlVVJMKHVybCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgIGNvbnN0IHZpZGVvRm9ybWF0cyA9IHVybC5zcGxpdCgvLCg/PW1wNFxcOnx3ZWJtXFw6fG9ndlxcOnxvZ2dcXDopLyk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgbGV0IHJlYWR5ID0gMDtcbiAgICB2aWRlb0Zvcm1hdHMuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICBjb25zdCBtYXRjaCA9IHZhbC5tYXRjaCgvXihtcDR8d2VibXxvZ3Z8b2dnKVxcOiguKikvKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSAmJiBtYXRjaFsyXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgcmVzdWx0W21hdGNoWzFdID09PSAnb2d2JyA/ICdvZ2cnIDogbWF0Y2hbMV1dID0gbWF0Y2hbMl07XG4gICAgICAgIHJlYWR5ID0gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVhZHkgPyByZXN1bHQgOiBmYWxzZTtcbiAgfVxuICBwbGF5KHN0YXJ0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2VsZi5wbGF5ZXIuY3VycmVudFRpbWUgPSBzdGFydDtcbiAgICB9XG4gICAgaWYgKHNlbGYucGxheWVyLnBhdXNlZCkge1xuICAgICAgLy8gRG9uJ3QgcGxheSBpZiB2aWRlbyBpcyBhbHJlYWR5IGVuZGVkIGFuZCB3aXRoIG5vIGxvb3AuXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmVuZFRpbWUgJiYgIXNlbGYub3B0aW9ucy5sb29wKSB7XG4gICAgICAgIHNlbGYuZ2V0Q3VycmVudFRpbWUoc2Vjb25kcyA9PiB7XG4gICAgICAgICAgaWYgKHNlY29uZHMgPCBzZWxmLm9wdGlvbnMuZW5kVGltZSkge1xuICAgICAgICAgICAgc2VsZi5wbGF5ZXIucGxheSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnBsYXllci5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdXNlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgc2VsZi5wbGF5ZXIucGF1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYucGxheWVyLnBhdXNlKCk7XG4gIH1cbiAgbXV0ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuJHZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLiR2aWRlby5tdXRlZCA9IGZhbHNlO1xuICB9XG4gIHNldFZvbHVtZSh2b2x1bWUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgdHlwZW9mIHZvbHVtZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi4kdmlkZW8udm9sdW1lID0gdm9sdW1lIC8gMTAwO1xuICB9XG4gIGdldFZvbHVtZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2soc2VsZi4kdmlkZW8udm9sdW1lICogMTAwKTtcbiAgfVxuICBnZXRNdXRlZChjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhzZWxmLiR2aWRlby5tdXRlZCk7XG4gIH1cbiAgc2V0Q3VycmVudFRpbWUoY3VycmVudFRpbWUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgdHlwZW9mIGN1cnJlbnRUaW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLiR2aWRlby5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIGdldEN1cnJlbnRUaW1lKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhzZWxmLnBsYXllci5jdXJyZW50VGltZSk7XG4gIH1cbiAgZ2V0SW1hZ2VVUkwoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi52aWRlb0ltYWdlKSB7XG4gICAgICBjYWxsYmFjayhzZWxmLnZpZGVvSW1hZ2UpO1xuICAgIH1cbiAgfVxuICBnZXRWaWRlbyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gcmV0dXJuIGdlbmVyYXRlZCB2aWRlbyBibG9ja1xuICAgIGlmIChzZWxmLiR2aWRlbykge1xuICAgICAgY2FsbGJhY2soc2VsZi4kdmlkZW8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdlbmVyYXRlIG5ldyB2aWRlbyBibG9ja1xuICAgIGxldCBoaWRkZW5EaXY7XG4gICAgaWYgKCFzZWxmLiR2aWRlbykge1xuICAgICAgaGlkZGVuRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBoaWRkZW5EaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkU291cmNlRWxlbWVudChlbGVtZW50LCBzcmMsIHR5cGUpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuICAgICAgc291cmNlLnNyYyA9IHNyYztcbiAgICAgIHNvdXJjZS50eXBlID0gdHlwZTtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCFzZWxmLiR2aWRlbykge1xuICAgICAgc2VsZi4kdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgc2VsZi5wbGF5ZXIgPSBzZWxmLiR2aWRlbztcblxuICAgICAgLy8gc2hvdyBjb250cm9sc1xuICAgICAgaWYgKHNlbGYub3B0aW9ucy5zaG93Q29udHJvbHMpIHtcbiAgICAgICAgc2VsZi4kdmlkZW8uY29udHJvbHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdm9sdW1lXG4gICAgICBpZiAodHlwZW9mIHNlbGYub3B0aW9ucy52b2x1bWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuc2V0Vm9sdW1lKHNlbGYub3B0aW9ucy52b2x1bWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBtdXRlIChpdCBpcyByZXF1aXJlZCB0byBtdXRlIGFmdGVyIHRoZSB2b2x1bWUgc2V0KVxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5tdXRlKSB7XG4gICAgICAgIHNlbGYubXV0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBsb29wXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmxvb3ApIHtcbiAgICAgICAgc2VsZi4kdmlkZW8ubG9vcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGF1dG9wbGF5IGVuYWJsZSBvbiBtb2JpbGUgZGV2aWNlc1xuICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICcnKTtcbiAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnd2Via2l0LXBsYXlzaW5saW5lJywgJycpO1xuXG4gICAgICAvLyBhZGQgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmFjY2Vzc2liaWxpdHlIaWRkZW4pIHtcbiAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnaWQnLCBzZWxmLnBsYXllcklEKTtcbiAgICAgIGhpZGRlbkRpdi5hcHBlbmRDaGlsZChzZWxmLiR2aWRlbyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhpZGRlbkRpdik7XG4gICAgICBPYmplY3Qua2V5cyhzZWxmLnZpZGVvSUQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgYWRkU291cmNlRWxlbWVudChzZWxmLiR2aWRlbywgc2VsZi52aWRlb0lEW2tleV0sIGB2aWRlby8ke2tleX1gKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbG9jU3RhcnRlZDtcbiAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgZSA9PiB7XG4gICAgICBpZiAoIWxvY1N0YXJ0ZWQpIHtcbiAgICAgICAgc2VsZi5maXJlKCdzdGFydGVkJywgZSk7XG4gICAgICB9XG4gICAgICBsb2NTdGFydGVkID0gMTtcbiAgICB9KTtcbiAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHNlbGYuZmlyZSgndGltZXVwZGF0ZScsIGUpO1xuXG4gICAgICAvLyBjaGVjayBmb3IgZW5kIG9mIHZpZGVvIGFuZCBwbGF5IGFnYWluIG9yIHN0b3BcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuZW5kVGltZSAmJiB0aGlzLmN1cnJlbnRUaW1lID49IHNlbGYub3B0aW9ucy5lbmRUaW1lKSB7XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCkge1xuICAgICAgICAgIHNlbGYucGxheShzZWxmLm9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgZSA9PiB7XG4gICAgICBzZWxmLmZpcmUoJ3BsYXknLCBlKTtcbiAgICB9KTtcbiAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGUgPT4ge1xuICAgICAgc2VsZi5maXJlKCdwYXVzZScsIGUpO1xuICAgIH0pO1xuICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgZSA9PiB7XG4gICAgICBzZWxmLmZpcmUoJ2VuZGVkJywgZSk7XG4gICAgfSk7XG4gICAgc2VsZi5wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBnZXQgdmlkZW8gd2lkdGggYW5kIGhlaWdodFxuICAgICAgc2VsZi52aWRlb1dpZHRoID0gdGhpcy52aWRlb1dpZHRoIHx8IDEyODA7XG4gICAgICBzZWxmLnZpZGVvSGVpZ2h0ID0gdGhpcy52aWRlb0hlaWdodCB8fCA3MjA7XG4gICAgICBzZWxmLmZpcmUoJ3JlYWR5Jyk7XG5cbiAgICAgIC8vIGF1dG9wbGF5XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmF1dG9wbGF5KSB7XG4gICAgICAgIHNlbGYucGxheShzZWxmLm9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCd2b2x1bWVjaGFuZ2UnLCBlID0+IHtcbiAgICAgIHNlbGYuZ2V0Vm9sdW1lKHZvbHVtZSA9PiB7XG4gICAgICAgIHNlbGYub3B0aW9ucy52b2x1bWUgPSB2b2x1bWU7XG4gICAgICB9KTtcbiAgICAgIHNlbGYuZmlyZSgndm9sdW1lY2hhbmdlJywgZSk7XG4gICAgfSk7XG4gICAgc2VsZi5wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlID0+IHtcbiAgICAgIHNlbGYuZmlyZSgnZXJyb3InLCBlKTtcbiAgICB9KTtcbiAgICBjYWxsYmFjayhzZWxmLiR2aWRlbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFZpZGVvV29ya2VyKHVybCwgb3B0aW9ucykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIE9iamVjdC5rZXlzKFZpZGVvV29ya2VyLnByb3ZpZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICghcmVzdWx0ICYmIFZpZGVvV29ya2VyLnByb3ZpZGVyc1trZXldLnBhcnNlVVJMKHVybCkpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBWaWRlb1dvcmtlci5wcm92aWRlcnNba2V5XSh1cmwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQgfHwgbmV3IFZpZGVvV29ya2VyQmFzZSh1cmwsIG9wdGlvbnMpO1xufVxuVmlkZW9Xb3JrZXIuQmFzZUNsYXNzID0gVmlkZW9Xb3JrZXJCYXNlO1xuVmlkZW9Xb3JrZXIucHJvdmlkZXJzID0ge1xuICBZb3V0dWJlOiBWaWRlb1dvcmtlcllvdXR1YmUsXG4gIFZpbWVvOiBWaWRlb1dvcmtlclZpbWVvLFxuICBMb2NhbDogVmlkZW9Xb3JrZXJMb2NhbFxufTtcblxuZnVuY3Rpb24gamFyYWxsYXhWaWRlbyQxKGphcmFsbGF4ID0gZ2xvYmFsJDIuamFyYWxsYXgpIHtcbiAgaWYgKHR5cGVvZiBqYXJhbGxheCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgSmFyYWxsYXggPSBqYXJhbGxheC5jb25zdHJ1Y3RvcjtcblxuICAvLyBhcHBlbmQgdmlkZW8gYWZ0ZXIgd2hlbiBibG9jayB3aWxsIGJlIHZpc2libGUuXG4gIGNvbnN0IGRlZk9uU2Nyb2xsID0gSmFyYWxsYXgucHJvdG90eXBlLm9uU2Nyb2xsO1xuICBKYXJhbGxheC5wcm90b3R5cGUub25TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgZGVmT25TY3JvbGwuYXBwbHkoc2VsZik7XG4gICAgY29uc3QgaXNSZWFkeSA9ICFzZWxmLmlzVmlkZW9JbnNlcnRlZCAmJiBzZWxmLnZpZGVvICYmICghc2VsZi5vcHRpb25zLnZpZGVvTGF6eUxvYWRpbmcgfHwgc2VsZi5pc0VsZW1lbnRJblZpZXdwb3J0KSAmJiAhc2VsZi5vcHRpb25zLmRpc2FibGVWaWRlbygpO1xuICAgIGlmIChpc1JlYWR5KSB7XG4gICAgICBzZWxmLmlzVmlkZW9JbnNlcnRlZCA9IHRydWU7XG4gICAgICBzZWxmLnZpZGVvLmdldFZpZGVvKHZpZGVvID0+IHtcbiAgICAgICAgY29uc3QgJHBhcmVudCA9IHZpZGVvLnBhcmVudE5vZGU7XG4gICAgICAgIHNlbGYuY3NzKHZpZGVvLCB7XG4gICAgICAgICAgcG9zaXRpb246IHNlbGYuaW1hZ2UucG9zaXRpb24sXG4gICAgICAgICAgdG9wOiAnMHB4JyxcbiAgICAgICAgICBsZWZ0OiAnMHB4JyxcbiAgICAgICAgICByaWdodDogJzBweCcsXG4gICAgICAgICAgYm90dG9tOiAnMHB4JyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIG1heFdpZHRoOiAnbm9uZScsXG4gICAgICAgICAgbWF4SGVpZ2h0OiAnbm9uZScsXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgIHRyYW5zZm9ybVN0eWxlOiAncHJlc2VydmUtM2QnLFxuICAgICAgICAgIGJhY2tmYWNlVmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgIHpJbmRleDogLTFcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYuJHZpZGVvID0gdmlkZW87XG5cbiAgICAgICAgLy8gYWRkIFBvc3RlciBhdHRyaWJ1dGUgdG8gc2VsZi1ob3N0ZWQgdmlkZW9cbiAgICAgICAgaWYgKHNlbGYudmlkZW8udHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgIGlmIChzZWxmLmltYWdlLnNyYykge1xuICAgICAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdwb3N0ZXInLCBzZWxmLmltYWdlLnNyYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmltYWdlLiRpdGVtICYmIHNlbGYuaW1hZ2UuJGl0ZW0udGFnTmFtZSA9PT0gJ0lNRycgJiYgc2VsZi5pbWFnZS4kaXRlbS5zcmMpIHtcbiAgICAgICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgncG9zdGVyJywgc2VsZi5pbWFnZS4kaXRlbS5zcmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBjbGFzc25hbWUgdG8gdmlkZW8gZWxlbWVudFxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnZpZGVvQ2xhc3MpIHtcbiAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYCR7c2VsZi5vcHRpb25zLnZpZGVvQ2xhc3N9ICR7c2VsZi5vcHRpb25zLnZpZGVvQ2xhc3N9LSR7c2VsZi52aWRlby50eXBlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5zZXJ0IHZpZGVvIHRhZ1xuICAgICAgICBzZWxmLmltYWdlLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodmlkZW8pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBwYXJlbnQgdmlkZW8gZWxlbWVudCAoY3JlYXRlZCBieSBWaWRlb1dvcmtlcilcbiAgICAgICAgJHBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCRwYXJlbnQpO1xuXG4gICAgICAgIC8vIGNhbGwgb25WaWRlb0luc2VydCBldmVudFxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLm9uVmlkZW9JbnNlcnQpIHtcbiAgICAgICAgICBzZWxmLm9wdGlvbnMub25WaWRlb0luc2VydC5jYWxsKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gY292ZXIgdmlkZW9cbiAgY29uc3QgZGVmQ292ZXJJbWFnZSA9IEphcmFsbGF4LnByb3RvdHlwZS5jb3ZlckltYWdlO1xuICBKYXJhbGxheC5wcm90b3R5cGUuY292ZXJJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBpbWFnZURhdGEgPSBkZWZDb3ZlckltYWdlLmFwcGx5KHNlbGYpO1xuICAgIGNvbnN0IG5vZGUgPSBzZWxmLmltYWdlLiRpdGVtID8gc2VsZi5pbWFnZS4kaXRlbS5ub2RlTmFtZSA6IGZhbHNlO1xuICAgIGlmIChpbWFnZURhdGEgJiYgc2VsZi52aWRlbyAmJiBub2RlICYmIChub2RlID09PSAnSUZSQU1FJyB8fCBub2RlID09PSAnVklERU8nKSkge1xuICAgICAgbGV0IGggPSBpbWFnZURhdGEuaW1hZ2UuaGVpZ2h0O1xuICAgICAgbGV0IHcgPSBoICogc2VsZi5pbWFnZS53aWR0aCAvIHNlbGYuaW1hZ2UuaGVpZ2h0O1xuICAgICAgbGV0IG1sID0gKGltYWdlRGF0YS5jb250YWluZXIud2lkdGggLSB3KSAvIDI7XG4gICAgICBsZXQgbXQgPSBpbWFnZURhdGEuaW1hZ2UubWFyZ2luVG9wO1xuICAgICAgaWYgKGltYWdlRGF0YS5jb250YWluZXIud2lkdGggPiB3KSB7XG4gICAgICAgIHcgPSBpbWFnZURhdGEuY29udGFpbmVyLndpZHRoO1xuICAgICAgICBoID0gdyAqIHNlbGYuaW1hZ2UuaGVpZ2h0IC8gc2VsZi5pbWFnZS53aWR0aDtcbiAgICAgICAgbWwgPSAwO1xuICAgICAgICBtdCArPSAoaW1hZ2VEYXRhLmltYWdlLmhlaWdodCAtIGgpIC8gMjtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHZpZGVvIGhlaWdodCBvdmVyIHRoYW4gbmVlZCB0byBoaWRlIGNvbnRyb2xzXG4gICAgICBpZiAobm9kZSA9PT0gJ0lGUkFNRScpIHtcbiAgICAgICAgaCArPSA0MDA7XG4gICAgICAgIG10IC09IDIwMDtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3NzKHNlbGYuJHZpZGVvLCB7XG4gICAgICAgIHdpZHRoOiBgJHt3fXB4YCxcbiAgICAgICAgbWFyZ2luTGVmdDogYCR7bWx9cHhgLFxuICAgICAgICBoZWlnaHQ6IGAke2h9cHhgLFxuICAgICAgICBtYXJnaW5Ub3A6IGAke210fXB4YFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZURhdGE7XG4gIH07XG5cbiAgLy8gaW5pdCB2aWRlb1xuICBjb25zdCBkZWZJbml0SW1nID0gSmFyYWxsYXgucHJvdG90eXBlLmluaXRJbWc7XG4gIEphcmFsbGF4LnByb3RvdHlwZS5pbml0SW1nID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGRlZmF1bHRSZXN1bHQgPSBkZWZJbml0SW1nLmFwcGx5KHNlbGYpO1xuICAgIGlmICghc2VsZi5vcHRpb25zLnZpZGVvU3JjKSB7XG4gICAgICBzZWxmLm9wdGlvbnMudmlkZW9TcmMgPSBzZWxmLiRpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC12aWRlbycpIHx8IG51bGw7XG4gICAgfVxuICAgIGlmIChzZWxmLm9wdGlvbnMudmlkZW9TcmMpIHtcbiAgICAgIHNlbGYuZGVmYXVsdEluaXRJbWdSZXN1bHQgPSBkZWZhdWx0UmVzdWx0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xuICB9O1xuICBjb25zdCBkZWZDYW5Jbml0UGFyYWxsYXggPSBKYXJhbGxheC5wcm90b3R5cGUuY2FuSW5pdFBhcmFsbGF4O1xuICBKYXJhbGxheC5wcm90b3R5cGUuY2FuSW5pdFBhcmFsbGF4ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBkZWZhdWx0UmVzdWx0ID0gZGVmQ2FuSW5pdFBhcmFsbGF4LmFwcGx5KHNlbGYpO1xuICAgIGlmICghc2VsZi5vcHRpb25zLnZpZGVvU3JjKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBJbml0IHZpZGVvIGFwaVxuICAgIGNvbnN0IHZpZGVvID0gbmV3IFZpZGVvV29ya2VyKHNlbGYub3B0aW9ucy52aWRlb1NyYywge1xuICAgICAgYXV0b3BsYXk6IHRydWUsXG4gICAgICBsb29wOiBzZWxmLm9wdGlvbnMudmlkZW9Mb29wLFxuICAgICAgc2hvd0NvbnRyb2xzOiBmYWxzZSxcbiAgICAgIGFjY2Vzc2liaWxpdHlIaWRkZW46IHRydWUsXG4gICAgICBzdGFydFRpbWU6IHNlbGYub3B0aW9ucy52aWRlb1N0YXJ0VGltZSB8fCAwLFxuICAgICAgZW5kVGltZTogc2VsZi5vcHRpb25zLnZpZGVvRW5kVGltZSB8fCAwLFxuICAgICAgbXV0ZTogIXNlbGYub3B0aW9ucy52aWRlb1ZvbHVtZSxcbiAgICAgIHZvbHVtZTogc2VsZi5vcHRpb25zLnZpZGVvVm9sdW1lIHx8IDBcbiAgICB9KTtcblxuICAgIC8vIGNhbGwgb25WaWRlb1dvcmtlckluaXQgZXZlbnRcbiAgICBpZiAoc2VsZi5vcHRpb25zLm9uVmlkZW9Xb3JrZXJJbml0KSB7XG4gICAgICBzZWxmLm9wdGlvbnMub25WaWRlb1dvcmtlckluaXQuY2FsbChzZWxmLCB2aWRlbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0RGVmYXVsdEltYWdlKCkge1xuICAgICAgaWYgKHNlbGYuaW1hZ2UuJGRlZmF1bHRfaXRlbSkge1xuICAgICAgICBzZWxmLmltYWdlLiRpdGVtID0gc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtO1xuICAgICAgICBzZWxmLmltYWdlLiRpdGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgIC8vIHNldCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIHNlbGYuY292ZXJJbWFnZSgpO1xuICAgICAgICBzZWxmLm9uU2Nyb2xsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aWRlby5pc1ZhbGlkKCkpIHtcbiAgICAgIC8vIEZvcmNlIGVuYWJsZSBwYXJhbGxheC5cbiAgICAgIC8vIFdoZW4gdGhlIHBhcmFsbGF4IGRpc2FibGVkIG9uIG1vYmlsZSBkZXZpY2VzLCB3ZSBzdGlsbCBuZWVkIHRvIGRpc3BsYXkgdmlkZW9zLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25rLW8vamFyYWxsYXgvaXNzdWVzLzE1OVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXgoKSkge1xuICAgICAgICBkZWZhdWx0UmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5pbWFnZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHNlbGYub3B0aW9ucy50eXBlID0gJ3Njcm9sbCc7XG4gICAgICAgIHNlbGYub3B0aW9ucy5zcGVlZCA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHBhcmFsbGF4IHdpbGwgbm90IGJlIGluaXRlZCwgd2UgY2FuIGFkZCB0aHVtYm5haWwgb24gYmFja2dyb3VuZC5cbiAgICAgIGlmICghZGVmYXVsdFJlc3VsdCkge1xuICAgICAgICBpZiAoIXNlbGYuZGVmYXVsdEluaXRJbWdSZXN1bHQpIHtcbiAgICAgICAgICB2aWRlby5nZXRJbWFnZVVSTCh1cmwgPT4ge1xuICAgICAgICAgICAgLy8gc2F2ZSBkZWZhdWx0IHVzZXIgc3R5bGVzXG4gICAgICAgICAgICBjb25zdCBjdXJTdHlsZSA9IHNlbGYuJGl0ZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgaWYgKGN1clN0eWxlKSB7XG4gICAgICAgICAgICAgIHNlbGYuJGl0ZW0uc2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LW9yaWdpbmFsLXN0eWxlcycsIGN1clN0eWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IG5ldyBiYWNrZ3JvdW5kXG4gICAgICAgICAgICBzZWxmLmNzcyhzZWxmLiRpdGVtLCB7XG4gICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogYHVybChcIiR7dXJsfVwiKWAsXG4gICAgICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICdiYWNrZ3JvdW5kLXNpemUnOiAnY292ZXInXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXQgdmlkZW9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZGVvLm9uKCdyZWFkeScsICgpID0+IHtcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnZpZGVvUGxheU9ubHlWaXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRPblNjcm9sbCA9IHNlbGYub25TY3JvbGw7XG4gICAgICAgICAgICBzZWxmLm9uU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBvbGRPblNjcm9sbC5hcHBseShzZWxmKTtcbiAgICAgICAgICAgICAgaWYgKCFzZWxmLnZpZGVvRXJyb3IgJiYgKHNlbGYub3B0aW9ucy52aWRlb0xvb3AgfHwgIXNlbGYub3B0aW9ucy52aWRlb0xvb3AgJiYgIXNlbGYudmlkZW9FbmRlZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZpZGVvLm9uKCdzdGFydGVkJywgKCkgPT4ge1xuICAgICAgICAgIHNlbGYuaW1hZ2UuJGRlZmF1bHRfaXRlbSA9IHNlbGYuaW1hZ2UuJGl0ZW07XG4gICAgICAgICAgc2VsZi5pbWFnZS4kaXRlbSA9IHNlbGYuJHZpZGVvO1xuXG4gICAgICAgICAgLy8gc2V0IHZpZGVvIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICBzZWxmLmltYWdlLndpZHRoID0gc2VsZi52aWRlby52aWRlb1dpZHRoIHx8IDEyODA7XG4gICAgICAgICAgc2VsZi5pbWFnZS5oZWlnaHQgPSBzZWxmLnZpZGVvLnZpZGVvSGVpZ2h0IHx8IDcyMDtcbiAgICAgICAgICBzZWxmLmNvdmVySW1hZ2UoKTtcbiAgICAgICAgICBzZWxmLm9uU2Nyb2xsKCk7XG5cbiAgICAgICAgICAvLyBoaWRlIGltYWdlXG4gICAgICAgICAgaWYgKHNlbGYuaW1hZ2UuJGRlZmF1bHRfaXRlbSkge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmlkZW8ub24oJ2VuZGVkJywgKCkgPT4ge1xuICAgICAgICAgIHNlbGYudmlkZW9FbmRlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFzZWxmLm9wdGlvbnMudmlkZW9Mb29wKSB7XG4gICAgICAgICAgICAvLyBzaG93IGRlZmF1bHQgaW1hZ2UgaWYgTG9vcCBkaXNhYmxlZC5cbiAgICAgICAgICAgIHJlc2V0RGVmYXVsdEltYWdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmlkZW8ub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgIHNlbGYudmlkZW9FcnJvciA9IHRydWU7XG5cbiAgICAgICAgICAvLyBzaG93IGRlZmF1bHQgaW1hZ2UgaWYgdmlkZW8gbG9hZGluZyBlcnJvci5cbiAgICAgICAgICByZXNldERlZmF1bHRJbWFnZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi52aWRlbyA9IHZpZGVvO1xuXG4gICAgICAgIC8vIHNldCBpbWFnZSBpZiBub3QgZXhpc3RzXG4gICAgICAgIGlmICghc2VsZi5kZWZhdWx0SW5pdEltZ1Jlc3VsdCkge1xuICAgICAgICAgIC8vIHNldCBlbXB0eSBpbWFnZSBvbiBzZWxmLWhvc3RlZCB2aWRlbyBpZiBub3QgZGVmaW5lZFxuICAgICAgICAgIHNlbGYuaW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyc7XG4gICAgICAgICAgaWYgKHZpZGVvLnR5cGUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHZpZGVvLmdldEltYWdlVVJMKHVybCA9PiB7XG4gICAgICAgICAgICAgIHNlbGYuaW1hZ2UuYmdJbWFnZSA9IGB1cmwoXCIke3VybH1cIilgO1xuICAgICAgICAgICAgICBzZWxmLmluaXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXN0cm95IHZpZGVvIHBhcmFsbGF4XG4gIGNvbnN0IGRlZkRlc3Ryb3kgPSBKYXJhbGxheC5wcm90b3R5cGUuZGVzdHJveTtcbiAgSmFyYWxsYXgucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuaW1hZ2UuJGRlZmF1bHRfaXRlbSkge1xuICAgICAgc2VsZi5pbWFnZS4kaXRlbSA9IHNlbGYuaW1hZ2UuJGRlZmF1bHRfaXRlbTtcbiAgICAgIGRlbGV0ZSBzZWxmLmltYWdlLiRkZWZhdWx0X2l0ZW07XG4gICAgfVxuICAgIGRlZkRlc3Ryb3kuYXBwbHkoc2VsZik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGphcmFsbGF4RWxlbWVudCQxKGphcmFsbGF4ID0gZ2xvYmFsJDIuamFyYWxsYXgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS53YXJuKFwiSmFyYWxsYXggRWxlbWVudCBleHRlbnNpb24gaXMgREVQUkVDQVRFRCwgcGxlYXNlLCBhdm9pZCB1c2luZyBpdC4gV2UgcmVjb21tZW5kIHlvdSBsb29rIGF0IHNvbWV0aGluZyBsaWtlIGBsYXguanNgIGxpYnJhcnkgPGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4Zm94eS9sYXguanM+LiBJdCBpcyBtdWNoIG1vcmUgcG93ZXJmdWwgYW5kIGhhcyBhIGxlc3MgY29kZSAoaW4gY2FzZXMgd2hlbiB5b3UgZG9uJ3Qgd2FudCB0byBhZGQgcGFyYWxsYXggYmFja2dyb3VuZHMpLlwiKTtcbiAgaWYgKHR5cGVvZiBqYXJhbGxheCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgSmFyYWxsYXggPSBqYXJhbGxheC5jb25zdHJ1Y3RvcjtcblxuICAvLyByZWRlZmluZSBkZWZhdWx0IG1ldGhvZHNcbiAgWydpbml0SW1nJywgJ2NhbkluaXRQYXJhbGxheCcsICdpbml0JywgJ2Rlc3Ryb3knLCAnY292ZXJJbWFnZScsICdpc1Zpc2libGUnLCAnb25TY3JvbGwnLCAnb25SZXNpemUnXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3QgZGVmID0gSmFyYWxsYXgucHJvdG90eXBlW2tleV07XG4gICAgSmFyYWxsYXgucHJvdG90eXBlW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoa2V5ID09PSAnaW5pdEltZycgJiYgc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtZWxlbWVudCcpICE9PSBudWxsKSB7XG4gICAgICAgIHNlbGYub3B0aW9ucy50eXBlID0gJ2VsZW1lbnQnO1xuICAgICAgICBzZWxmLnB1cmVPcHRpb25zLnNwZWVkID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtZWxlbWVudCcpIHx8ICcxMDAnO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYub3B0aW9ucy50eXBlICE9PSAnZWxlbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGRlZi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHNlbGYucHVyZU9wdGlvbnMudGhyZXNob2xkID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhyZXNob2xkJykgfHwgJyc7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzcGVlZEFyciA9IGAke3NlbGYucHVyZU9wdGlvbnMuc3BlZWR9YC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLnNwZWVkID0gc2VsZi5wdXJlT3B0aW9ucy5zcGVlZCB8fCAwO1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLnNwZWVkWSA9IHNwZWVkQXJyWzBdID8gcGFyc2VGbG9hdChzcGVlZEFyclswXSkgOiAwO1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLnNwZWVkWCA9IHNwZWVkQXJyWzFdID8gcGFyc2VGbG9hdChzcGVlZEFyclsxXSkgOiAwO1xuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkQXJyID0gc2VsZi5wdXJlT3B0aW9ucy50aHJlc2hvbGQuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy50aHJlc2hvbGRZID0gdGhyZXNob2xkQXJyWzBdID8gcGFyc2VGbG9hdCh0aHJlc2hvbGRBcnJbMF0pIDogbnVsbDtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy50aHJlc2hvbGRYID0gdGhyZXNob2xkQXJyWzFdID8gcGFyc2VGbG9hdCh0aHJlc2hvbGRBcnJbMV0pIDogbnVsbDtcbiAgICAgICAgICAgIGRlZi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgICAgICAgLy8gcmVzdG9yZSBiYWNrZ3JvdW5kIGltYWdlIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3R5bGVzVGFnID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJyk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdHlsZXNUYWcpIHtcbiAgICAgICAgICAgICAgc2VsZi4kaXRlbS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgb3JpZ2luYWxTdHlsZXNUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdvblJlc2l6ZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZGVmVHJhbnNmb3JtID0gc2VsZi5jc3Moc2VsZi4kaXRlbSwgJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgc2VsZi5jc3Moc2VsZi4kaXRlbSwge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBzZWxmLiRpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgc2VsZi5pdGVtRGF0YSA9IHtcbiAgICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgIHk6IHJlY3QudG9wICsgc2VsZi5nZXRXaW5kb3dEYXRhKCkueSxcbiAgICAgICAgICAgICAgeDogcmVjdC5sZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5jc3Moc2VsZi4kaXRlbSwge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06IGRlZlRyYW5zZm9ybVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ29uU2Nyb2xsJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB3bmQgPSBzZWxmLmdldFdpbmRvd0RhdGEoKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclBlcmNlbnQgPSAod25kLnkgKyB3bmQuaGVpZ2h0IC8gMiAtIHNlbGYuaXRlbURhdGEueSAtIHNlbGYuaXRlbURhdGEuaGVpZ2h0IC8gMikgLyAod25kLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgY29uc3QgbW92ZVkgPSBjZW50ZXJQZXJjZW50ICogc2VsZi5vcHRpb25zLnNwZWVkWTtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVYID0gY2VudGVyUGVyY2VudCAqIHNlbGYub3B0aW9ucy5zcGVlZFg7XG4gICAgICAgICAgICBsZXQgbXkgPSBtb3ZlWTtcbiAgICAgICAgICAgIGxldCBteCA9IG1vdmVYO1xuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy50aHJlc2hvbGRZICE9PSBudWxsICYmIG1vdmVZID4gc2VsZi5vcHRpb25zLnRocmVzaG9sZFkpIG15ID0gMDtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMudGhyZXNob2xkWCAhPT0gbnVsbCAmJiBtb3ZlWCA+IHNlbGYub3B0aW9ucy50aHJlc2hvbGRYKSBteCA9IDA7XG4gICAgICAgICAgICBzZWxmLmNzcyhzZWxmLiRpdGVtLCB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7bXh9cHgsJHtteX1weCwwKWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdpbml0SW1nJzpcbiAgICAgICAgY2FzZSAnaXNWaXNpYmxlJzpcbiAgICAgICAgY2FzZSAnY292ZXJJbWFnZSc6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIG5vIGRlZmF1bHRcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWYuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbmNvbnN0IGphcmFsbGF4ID0gamFyYWxsYXgkMTtcbmNvbnN0IGphcmFsbGF4VmlkZW8gPSBmdW5jdGlvbiBqYXJhbGxheFZpZGVvKCkge1xuICByZXR1cm4gamFyYWxsYXhWaWRlbyQxKGphcmFsbGF4KTtcbn07XG5jb25zdCBqYXJhbGxheEVsZW1lbnQgPSBmdW5jdGlvbiBqYXJhbGxheEVsZW1lbnQoKSB7XG4gIHJldHVybiBqYXJhbGxheEVsZW1lbnQkMShqYXJhbGxheCk7XG59O1xuXG5leHBvcnQgeyBqYXJhbGxheCwgamFyYWxsYXhFbGVtZW50LCBqYXJhbGxheFZpZGVvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qYXJhbGxheC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jarallax/dist/jarallax.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jarallax/dist/jarallax.css":
/*!*************************************************!*\
  !*** ./node_modules/jarallax/dist/jarallax.css ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"4c293dd14196\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamFyYWxsYXgvZGlzdC9qYXJhbGxheC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2xhay1OZXh0SlMvLi9ub2RlX21vZHVsZXMvamFyYWxsYXgvZGlzdC9qYXJhbGxheC5jc3M/NmFhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjRjMjkzZGQxNDE5NlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jarallax/dist/jarallax.css\n");

/***/ })

};
;